<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2019%2F10%2F20%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程通信操作系统随机调度线程，程序员不能预知线程的执行顺序 下面两种情况下线程之间需要通信： 多个线程访问共享资源而不希望共享资源遭到破坏（互斥） 一个线程需要将某个任务已经完成的情况通知另外一个或多个线程时。（同步） Windows线程通信方法主要有：互锁函数、临界区、事件、互斥量、信号量 互锁函数1234567891011Long g_x = 0;DWORD WINAPI ThreadFunc1(Pvoid pvParam)&#123; g_x++; return 0;&#125;DWORD WINAPI ThreadFunc2(PVOID pvParam)&#123; g_x++; return 0;&#125; 当上面两线程同时执行时，难免会遇到同时写g_x的情况发生（即前面说的互斥），这会导致g_x结果错误。为此可用互锁函数解决。 互锁函数是用来解决原子访问的，主要针对变量的原子访问； 原子访问： 当线程访问资源时，能够确保没有其他线程同时访问相同资源 12LONG InterlockedExchangeAdd(PLONG plAddend,LONG lIncrement);//用一个32位数值执行加法的原子操作 1234567891011Long g_x=0;DWORD WINAPI ThreadFunc1(PVOID pvParam)&#123; InterlockedExchangeAdd(&amp;g_x,1); return 0;&#125;DWORD WINAPI ThreadFunc2(PVOID pvParam)&#123; InterlockedExchangeAdd(&amp;g_x,1); return 0;&#125; 12LONG InterlockedExchange(PLONG plTarget,LONG lValue);//以原子操作方式用第二个参数的值取代第一个参数的当前值 12LONG InterlockedCompareExchange(PLONG plDestination,LONG lExchange,LONG lComparand);//比较第一个参数和第三个参数的值，如果相等，则将第一个参数所指位置的值置为第二个参数，如果不相等则不进行任何操作。 例：10000个2相加 单线程123456789int main()&#123; int sum = 0; for(int i=0;i&lt;=10000;i++)&#123; sum = sum + 2; &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 多线程1234567891011121314151617181920212223242526#include"windows.h"long sum = 0;DWORD WINAPI ThreadFunc1(PVOID pvParam)&#123; for(int i=1;i&lt;=5000;i++)&#123; InterlockedExchangeAdd(&amp;sun,2); // sum = sum+2; &#125; return 0;&#125;DWORD WINAPI ThreadFunc2(PVOID pvParam)&#123; for(int i=5001;i&lt;=10000;i++)&#123; InterlockedExchangeAdd(&amp;sum,2); //sum = sum + 2; &#125; &#125;int main()&#123; HANDLE ThreadHandle1 = CreateThread(NULL,0,ThreadFunc1,NULL,0,NULL); HANDLE ThreadHandle2 = CreateThread(NULL,0,ThreadFunc2,NULL,0,NULL); HANDLE ThreadHandles[2] = &#123;ThreadHandle1,ThreadHandle2&#125;; WaitForMultipleObjects(2,ThreadHandles,TRUE,INFINITE); cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 临界区互锁函数：以原子操作方式修改单个值 临界区：以原子方式修改复杂的数据结构，也称为关键代码段，指一小段代码。 访问临界区的原则： 一次最多只能一个线程停留在临界区。 不能让一个线程无限地停留在临界区内。 12345678910//首先定义一个临界区对象（通常是全局变量）CRITICAL_SECTION cs;//临界区对象初始化InitializeCriticalSection (&amp;cs);//进入临界区EnterCriticalSection(&amp;cs);//离开临界区LeaveCriticalSection(&amp;cs);//释放临界区对象DeleteCriticalSection(&amp;cs); 例： 不加临界区12345678910111213141516171819202122232425262728#include&lt;windows.h&gt;#include&lt;fstream&gt;#include&lt;bits/stdc++.h&gt;fstream file;DWORD WINAPI ThreadFunc1(PVOID pvParam)&#123; for(int i=1;i&lt;=1000;i++)&#123; file&lt;&lt;"ThreadFunc1 Output"&lt;&lt;i&lt;&lt;endl; &#125; return 0;&#125;DWORD WINAPI ThreadFunc2(PVOID pvParam)&#123; for(int i=1;i&lt;=1000;i++)&#123; file&lt;&lt;"ThreadFunc2 Output"&lt;&lt;i&lt;&lt;endl; &#125; return 0;&#125;int main()&#123; file.open("data.txt",ios::out); HANDLE ThreadHandle1 = CreateThread(NULL,0,ThreadFunc1,NULL,0,NULL); HANDLE ThreadHandle2 = CreateThread(NULL,0,ThreadFunc2,NULL,0,NULL); HANDLE ThreadHandles[2] = &#123;ThreadHandle1,ThreadHandle2&#125;; WaitForMultipleObjects(2,ThreadHandles,TRUE,INFINITE); file.close(); return 0;&#125; 部分输出结果如下 12345678ThreadFunc1 Output103ThreadFunc1 Output104ThreadFunc1 Output104ThreadFunc1 Output105ThreadFunc2 Output99ThreadFunc1 Output106ThreadFunc2 Output100ThreadFunc1 Output107ThreadFunc2 Output101 可以看到两个线程同时写data.txt这个文件，有错误发生，ThreadFunc1连续输出了两次104。 加临界区代码如下 12345678910111213141516171819202122232425262728293031323334#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;fstream file;CRITICAL_SECTION cs;DWORD WINAPI ThreadFunc1(PVOID pvParam)&#123; EnterCriticalSection(&amp;cs); for(int i=1;i&lt;=1000;i++)&#123; file&lt;&lt;"ThreadFunc1 Output"&lt;&lt;i&lt;&lt;endl; &#125; LeaveCriticalSection(&amp;cs); return 0;&#125;DWORD WINAPI ThreadFunc2(PVOID pvParam)&#123; EnterCriticalSection(&amp;cs); for(int i=1;i&lt;=1000;i++)&#123; file&lt;&lt;"ThreadFunc2 Output"&lt;&lt;i&lt;&lt;endl; &#125; LeaveCriticalSection(&amp;cs); return 0;&#125;int main()&#123; file.open("data2.txt",ios::out); InitializeCriticalSection (&amp;cs); HANDLE ThreadHandle1 = CreateThread(NULL,0,ThreadFunc1,NULL,0,NULL); HANDLE ThreadHandle2 = CreateThread(NULL,0,ThreadFunc2,NULL,0,NULL); HANDLE ThreadHandles[2] = &#123;ThreadHandle1,ThreadHandle2&#125;; WaitForMultipleObjects(2,ThreadHandles,TRUE,INFINITE); file.close(); return 0;&#125; 此时输出结果如下： 12345678910ThreadFunc1 Output1ThreadFunc1 Output2ThreadFunc1 Output3ThreadFunc1 Output4ThreadFunc1 Output5ThreadFunc1 Output6ThreadFunc1 Output7ThreadFunc1 Output8ThreadFunc1 Output9ThreadFunc1 Output10 线程1先创建先执行，直到线程1输出1000 return后线程2 再执行。 当线程长时间得不到执行需要的资源时，会进入休眠状态，线程休眠再唤醒非常耗时，为了避免让线程休眠：TryEnterCriticalSection() 12345while(couter&lt;100)&#123; while(!TryEnterCriticalSection(&amp;cs)) int number = count++; LeaveCriticalSection(&amp;cs);&#125; 如果临界区当前线程会很快离开，等待进入临界区的线程可以短暂旋转。否则，线程旋转预定次数之后进入休眠状态，直到另一个线程离开临界区。 设置旋转次数： 12InitializeCriticalSectionAndSpinCout(&amp;cs,1000);SetCriticalSectionSpinCout(&amp;cs,1000); 互斥量互斥量是一种内核对象，确保多个线程对共享资源的互斥访问权。 一个使用计数 一个线程ID 一个递归计数器 线程ID标识系统中哪个线程拥有互斥量，为0标识没有线程拥有。 递归计数器指明线程拥有互斥量的次数。 互斥量的创建，返回句柄 1234567HANDLE CreateMutex( PSECURITY_ATTRIBUTES psa,//安全属性的指针 BOOL bInitialOwner,//初始化互斥量对象的所有者 PCTSTR pszName //指向互斥对象名的指针);InitialOwner: FALSE,互斥对象的线程ID和递归计数器均被设置为0 : TRUE,互斥对象的线程ID被设置为调用线程的ID，递归计数器被设置为1 打开一个已存在的命名互斥对象： 12345678HANDLE OpenMutex( DWORD fdwAccess, //access BOOL bInheritHandle,//inheritance option PCTSTR pszName//object name);- MUTEX_ALL_ACCESS 请求对互斥对象的完全访问- MUTEX_MODIFY_STATE 允许使用ReleaseMutex函数- SYNCHRONIZE 允许使用互斥对象同步 释放互斥量HANDLE ReleaseMutex(HANDLE hMutex); 等待互斥量 1234DWORD WaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds); 互斥量不同于其他内核对象，互斥对象有一个“线程所有权”的概念。 例： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;fstream file;DWORD WINAPI ThreadFunc1(PVOID param)&#123; HANDLE *phMutex = (HANDLE *)param; for(int i=1;i&lt;=100;i++) &#123; WaitForSingleObject(*phMutex,INFINITE); file &lt;&lt; "ThreadFunc1 Output" &lt;&lt; i &lt;&lt; endl; ReleaseMutex(*phMutex); &#125; return 0;&#125;DWORD WINAPI ThreadFunc2(PVOID param)&#123; HANDLE *phMutex = (HANDLE *)param; for(int i = 1;i&lt;=100;i++) &#123; WaitForSingleObject(*phMutex,INFINITE); file &lt;&lt; "ThreadFunc2 Output " &lt;&lt; i &lt;&lt; endl; ReleaseMutex(*phMutex); &#125; return 0;&#125;int main()&#123; file.open("data.txt",ios::out); HANDLE hMutex = CreateMutex(NULL,FALSE,"DisplayMutex"); HANDLE ThreadHandle1 = CreateThread(NULL,0,ThreadFunc1,&amp;hMutex,0,NULL); HANDLE ThreadHandle2 = CreateThread(NULL,0,ThreadFunc2,&amp;hMutex,0,NULL); HANDLE hThread[2] = &#123;ThreadHandle1,ThreadHandle2&#125;; WaitForMultipleObjects(2,hThread,TRUE,INFINITE); CloseHandle(hMutex); file.close(); return 0;&#125; 代码运行结果如下： 1234567891011ThreadFunc1 Output30ThreadFunc2 Output 30ThreadFunc1 Output31ThreadFunc2 Output 31ThreadFunc1 Output32ThreadFunc2 Output 32ThreadFunc1 Output33ThreadFunc2 Output 33ThreadFunc1 Output34ThreadFunc2 Output 34ThreadFunc1 Output35 信号量信号量是一种内核对象 一个使用计数 当前资源数量 最大资源数量 信号量可用于资源管理 信号量使用规则： 当前资源数量大于0，则等待信号量的线程获得资源继续运行，当前资源数量减一 当前资源数量等于0，则等待信号量的线程继续等待，直到有线程释放信号量，使当前资源数量大于0 123456789101112131415161718192021222324252627//创建信号量HANDLE CreateSemaphore( PSECURITY_ATTRIBUTES psa, LONG lInitialCount, //initial count LONG lMaximumCout, //maximum count PCTSTR pszName //object 那么);//打开一个已经存在的命名信号量对象HANDLE OpenSemaphore( DWORD fdwAccess, BOOL bInheritHandle, //inheritance option PCTSTR pszName //object name);- SEMAPHORE_ALL_ACCESS 要求对信号量完全访问- SEMAPHORE_MODIFY_STATE 运行使用ReleaseSemaphore函数- SYNCHRONIZE 允许使用信号量同步//释放信号量ReleaseSemaphore( HANDLE hSem, LONG lReleaseCount, PLONG plPreviousCout);//等待信号量DWORD WaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds); 创建线程 12345678HANDLE CreateThread( PSECURITY_ATTRIBUTES psa, //NULL DWORD cbStack, // 0 PTHREAD_START_ROUTINE pStartAddr, //线程函数地址 PVOID pvParam, //函数参数 NULL DWORD fdwCreate, //控制创建线程标志 0 PDWORD pdwThreadId // NULL); 死锁的规范定义：当一组进程的每一个进程都在等待一个事件，而这一事件只能由这一组进程的另一个进程所引起，那么这组进程就处于死锁状态。 死锁是指多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将永远不能向前推进 计算机系统中，如果系统的资源分配策略不当，更常见的可能是程序员写的程序有错误等，则会导致进程因竞争资源不当而产生死锁的现象。 死锁发生原因： 竞争资源 进程推进顺序非法 死锁发生条件： 互斥：任一时刻只允许一个进程使用资源 请求和保持：进程在请求其余资源时，不主动释放已经占有的资源 非剥夺：进程已经占有资源不会被强制剥夺 环路等待：环路中每一条边是进程在请求另一进程占有的资源 处理死锁的基本方法： 预防死锁：破坏四个必要条件中的一个，容易实现，但是会导致系统吞吐率和资源利用率降低 避免死锁：用某种方法在资源动态分配过程中，防止系统进入不安全状态。实现有难度，但可获得较高的资源利用率和系统吞吐率。 检测死锁：允许死锁发生，通过检测机构检测，然后采取措施，清除死锁。 解除死锁：与检测配套完成，常通过挂起或撤销一些进程实现。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fork]]></title>
    <url>%2F2019%2F10%2F20%2Ffork%2F</url>
    <content type="text"><![CDATA[头文件unistd.h fork调用的奇妙之处在于它仅仅被调用一次，却能够返回两次，它有三种不同值： 在父进程中，fork返回新创建子进程的进程id 在子进程中，fork返回0 如果出现错误，返回一个负数 fork函数执行完毕，如果创建进程成功，则出现两个进程，一个进程是父进程，一个是子进程，在父进程中，fork函数返回值是子进程的进程ID ，在子进程中fork返回0。 引用一位网友的话来解释fpid的值为什么在父子进程中不同。“其实就相当于链表，进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id,因为子进程没有子进程，所以其fpid为0. fork出错可能有两种原因]]></content>
      <tags>
        <tag>linux</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈夫曼树]]></title>
    <url>%2F2019%2F09%2F30%2F%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%2F</url>
    <content type="text"><![CDATA[准备知识 路径和路径长度 从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度。 现有一个仅有三个结点的二叉树，根结点root，左子结点left，右子结点right，则从left经root到right称为一条路径，路径长度为3。（通俗点讲路径长度即通路上结点间连线的条数） 树的路径长度：树的路径长度就是从根结点到每一结点的路经长度之和，前例中树的路径长度为1+1=2。 节点的权及带权路径长度 若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。 结点的带权路径长度：从根结点到该结点之间的路径长度与该结点权的乘积。 树的带权路径长度 树的带权路径长度：树中所有叶子结点的带权路径长度之和，记为WPL。 哈夫曼树给定N个权值为N作为N个叶子结点，构造一颗二叉树，若该树的带权路径长度达到最小，称这样的树为哈夫曼树，也称为最优二叉树。 哈夫曼树是带权路径长度最短的树，权值较大的结点离根结点较近。 哈夫曼树的主要应用是通过对原始数据的重新编码（这种编码称为哈夫曼编码）来实现数据压缩与解压缩（编码与译码）。 熵和最小冗余熵：根据信息的内容所有数据都会表现出一定的特性，称为熵。一组数据的熵是数据中每个符号熵的总和，符号z的熵S定义为： 构造哈夫曼树压缩和解压缩数据前缀树：前缀树是指一组代码中的任何一个编码都不是另外一个编码的前缀，这就保证了编码被解码时不会有多义性 哈夫曼树的效率]]></content>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F15%2F%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%2F</url>
    <content type="text"><![CDATA[进程同步 基本概念 进程同步机制的主要任务，是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则（或时序）共享系统资源，并能很好的相互合作，从而使程序的执行具有可再现性。 两种形式的制约关系 间接相互制约关系 互斥——竞争 直接相互制约关系 同步——协作 临界资源 分区 进入区enter section 临界区critical section 退出区exit section 剩余区remainder section 同步机制应遵循的规则 空闲让进 当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。 忙则等待 当已有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。 有限等待 对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区，以免陷入“死等”状态。 让权等待 当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等状态。 进程同步机制 软件同步机制:都没有解决让权等待，而且部分方法还会产生死锁的情况 硬件同步机制 关中断 * 利用Test-and-Set指令实现互斥 * 利用swap指令实现进程互斥 * 信号量机制 * 整型信号量 * 记录型信号量 * 由于整型信号量没有遵循让权等待原则，记录型允许负数，即阻塞链表 * AND型信号量 * 信号量集 * 理解:AND型号量的wait和signal仅能对信号施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配前，都必须测试资源数量，判断是否大于可分配的下限值，决定是否予以分配 * 操作 * Swait(S1，t1，d1…Sn，tn，dn) * Ssignal(S1，d1…Sn，dn) * 特殊情况 经典进程的同步问题 生产者–消费者问题 哲学家进餐问题 读者–写者问题]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F15%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[第二章进程的描述与控制前驱图和程序执行程序并发执行程序的并发执行程序并发执行时的特征 间断性 失去封闭性 不可再现性进程的描述进程的定义 进程是程序的一次执行 进程是一个程序及其数据在处理机上顺序执行时所发生的活动 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位进程的特征动态性 进程的实质时进程实体的执行过程，因此，动态性就是进程的最基本的特征。 动态性还表现在：“它由创建而产生，由调度而执行，由撤销而消亡。”可见进程实体有一定的生命期，而程序只是一组有序指令的集合，并存放在某种介质上，其本身并不具有活动的含义，因而是静态的。 并发性是指多个进程实体同存于内存中，且能在一段时间内同时运行。 引入进程的目的也正是为了使其进程实体能和其他进程实体并发执行。因此，并发性是进程的另一重要特征，同时也成为了OS的重要特征。而程序（没有建立PCB）是不能参与并发执行的 独立性在传统的OS中，独立性是指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB的程序都不能作为一个独立的单位参与运行。 异步性是指进程是按异步方式运行的，即按各自独立的、不可预知的速度向前推进。这才导致了传统意义上的程序若参与并发执行，会产生其结果的不可再现性。为使进程在并发运行时虽具有异步性，但仍能版正进程并发执行的结果是可再现的，在OS中引入了进程的概念，并且配置响应的进程同步机制。 从操作系统角度分类 系统进程 用户进程 进程和程序的区别 进程是动态概念，而程序则是静态概念 程序是指令的有序集合，永远存在；进程强调是程序在数据集上的一次执行，有创建有撤销，存在是暂时的； 进程具有并发性，而程序没有 进程可创建其他进程，而程序并不能形成新的程序 进程是竞争计算机资源的基本单位，程序不是 进程和程序的联系 进程是程序在数据集上的一次执行 程序是构成进程的组成部分，一个程序可对应多个进程，一个进程可包括多个程序 进程的运行目标是执行所对应的程序 从静态看，进程由程序、数据和进程控制块（PCB）组成 进程的基本状态及转换 进程的三种基本状态 就绪状态ready 执行状态running 阻塞状态block 三种基本状态的转换 创建状态和终止状态 五状态进程模型 注意 阻塞态-&gt;运行态和就绪态-&gt;阻塞态这二种状态转换不可能发生挂起操作和进程状态的转换 挂起和阻塞的区别 挂起操作的目的 终端用户的需要: 修改、检查进程 父进程的需要：修改、协调子进程 对换的需要：缓和内存 负荷调节的需要：保证实时任务的执行 关键图 进程管理中的数据结构 进程控制块PCB的作用 作为独立运行基本单位的标志 能实现间断性运行方式 提供进程管理所需要的信息 提供进程调度所需要的信息 实现与其他进程的同步与通信 进程控制块的信息 进程标识符 外部标识符PID 内部标识符(端口) 处理机状态 通用寄存器 指令计数器 程序状态字PSW 用户栈指针 进程调度信息 进程状态 进程优先级 进程调度所需的其他信息 事件 进程控制信息 程序和数据的地址 进程同步和通信机制 资源清单 链接指针 进程控制块的组织方式 线性方式 链接方式 索引方式进程控制操作系统内核 两大功能 支撑功能 中断管理 时钟管理 原语操作 进程的管理，由若干原语（primitive）来执行 资源管理功能 进程管理 存储器管理 设备管理 状态 系统态，管态，内核态 用户态，目态进程的创建 进程的层次结构 父进程 子进程 引起创建进程的事件 用户登录 作业调度 提供服务 应用请求 进程的创建过程 1.申请空白PCB 2.为新进程分配其运行所需的资源 3.初始化进程块PCB 4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列 进程的终止 引起进程终止的事件 1.正常结束 2.异常结束 3.外界干预 进程的终止过程 1.根据被终止进程的标识符 进程的阻塞与唤醒 引起进程阻塞和唤醒的事件 请求系统服务而未满足 启动某种操作而阻塞当前进程 新数据尚未到达 无新工作可做：系统进程 进程阻塞过程(自己阻塞自己) 进程唤醒过程(系统或其他进程唤醒自己) 进程的挂起与激活 suspend active进程同步 基本概念 进程同步机制的主要任务，是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则（或时序）共享系统资源，并能很好的相互合作，从而使程序的执行具有可再现性。 两种形式的制约关系 间接相互制约关系 互斥——竞争 直接相互制约关系 同步——协作 临界资源 分区 进入区enter section 临界区critical section 退出区exit section 剩余区remainder section 同步机制应遵循的规则 空闲让进 当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。 忙则等待 当已有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。 有限等待 对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区，以免陷入“死等”状态。 让权等待 当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等状态。 进程同步机制 软件同步机制:都没有解决让权等待，而且部分方法还会产生死锁的情况 硬件同步机制 关中断 * 利用Test-and-Set指令实现互斥 * 利用swap指令实现进程互斥 * 信号量机制 * 整型信号量 * 记录型信号量 * 由于整型信号量没有遵循让权等待原则，记录型允许负数，即阻塞链表 * AND型信号量 * 信号量集 * 理解:AND型号量的wait和signal仅能对信号施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配前，都必须测试资源数量，判断是否大于可分配的下限值，决定是否予以分配 * 操作 * Swait(S1，t1，d1…Sn，tn，dn) * Ssignal(S1，d1…Sn，dn) * 特殊情况 经典进程的同步问题 生产者–消费者问题 哲学家进餐问题 读者–写者问题进程通信进程通信是指进程之间的信息交换，又称低级进程通信进程通信的类型 共享存储器系统 基于共享数据结构的通信方式 生产者和消费者 基于共享存储区的通信方式 高级通信 管道通信系统(pipe) 高级通信 消息传递系统 高级通信 方式分类 直接通信 间接通信 客服机–服务器系统消息传递通信的实现方式 直接消息传递系统 信箱通信线程的基本概念线程的引入 线程的引入正是为了简化线程间的通信，以小的开销来提高进程内的并发程度 多线程并发的不足 进程的两个基本属性 一个拥有资源的独立单位，可独立分配系统资源 一个可独立调度和分派的基本单位，PCB 程序并发执行所需付出的时空开销 创建进程 撤销进程 进程切换 进程间通信效率低 将分配资源和调度两个属性分开 线程——作为调度和分派的基本单位 进程是系统资源分配的单位，线程是处理器调度的单位 线程表示进程的一个控制点，可以执行一系列的指令。通常，和应用程序的一个函数相对应 进程分解为线程还可以有效利用多处理器和多核计算机线程与进程的比较 不同点 调度的基本单位 并发性 相似点 状态：运行、阻塞、就绪 线程具有一定的生命期 进程可创建线程，一个线程可创建另一个子线程 多个线程并发执行时仍然存在互斥与同步线程的实现 线程的实现方式 内核支持线程KST 用户级线程ULT 组合方式 多线程OS中的进程属性 进程是一个可拥有资源的基本单位 多个线程可并发执行 进程已不是可执行的实体 线程的状态和线程控制块 线程运行的三个状态 执行状态 就绪状态 阻塞状态 线程控制块TCB]]></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统的发展]]></title>
    <url>%2F2019%2F09%2F06%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[未配置操作系统的计算机系统人工操作方式早期的操作方式是由程序员将事先已穿孔的纸带（或卡片）装入纸带输入机（或卡片输入机），再启动他们将纸带（或卡片）上的程序和数据输入计算机，然后启动计算机运行。仅当程序运行完毕并取走计算结果后才允许下一个用户上机。 缺点： 用户独占全机，及一台计算机的全部资源由上机用户所独占。 CPU等待人工操作。 人工操作方式严重降低了计算机资源的利用率，此即所谓的人机矛盾。 虽然CPU的速度再迅速提高，但I/O设备的速度却提高缓慢，使得CPU与I/O设备之间速度不匹配的矛盾更突出。 为此，曾先后出现了通道技术、缓冲技术，然而都未能很好地解决上述矛盾，直到后来引入了脱机输入/输出技术，才获得了相对较为满意的结果。 脱机输入/输出方式（Off-Line I/O） 目的：为解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，20世纪50年代末出现了脱机I/O技术。 实现：事先将装有用户程序和数据的纸带装入纸带输入机，在一台外围机的控制下，把纸带上的数据输入到磁带上。当CPU需要这些程序和数据时，再从磁带上高速地调入内存。 当CPU需要输出时，可先由CPU把数据直接从内存高速地输送到磁带上，然后在另一台外围机的控制下，再将磁带上的结果通过相应的输出设备输出。 优点： 减少了CPU的空闲时间。装带、卸带以及将数据从低速I/O设备送到高速磁带上的操作都是在脱机情况下由外围机完成的，并不占用主机时间，从而有效的减少了CPU的空闲时间。 提高了I/O速度。当CPU在运行中需要输入数据时，是直接从高速的磁带上将数据输入到内存的，这便极大地提高了I/O速度，从而进一步减少了CPU的空闲时间。 由于程序和数据的输入和输出都是再外围机的控制下完成的，或者说，他们是在脱离主机的情况下进行的，故称为脱机输入/输出方式。反之，把在主机的直接控制下进行输入/输出的方式称为联机输入/输出方式。 单道批处理系统（Simple Batch Processing System）20世纪50年代中期出现了第二代晶体管计算机，此时计算机虽已具有推广应用的价值，但计算机系统仍然非常昂贵。为了能充分提高它的利用率，应尽量保持系统的连续运行，即在处理完一个作业后，紧接着处理下一个作业，以减少及其的空闲等待时间。 单道批处理系统的处理过程为实现对作业的连续处理，需要先把一批作业以脱机方式输入到磁带上，并在系统中配上监督程序，在他的控制下，使这一批作业能一个接一个地连续处理。其处理过程是:首先由监督程序将磁带上的第一个作业装入内存，并把运行控制权交给该作业；当该作业处理完成时，又把控制权交还给监督程序，再由监督程序把磁带上的第二个作业调入内存，计算机系统就这样自动地一个作业紧接着一个作业地进行处理，直至磁带上的所有作业全部完成，这样便形成了早期的批处理系统，虽然系统对作业的处理是成批进行的，但在内存中始终只保持一道作业，故称为单道批处理系统。 由上所述不难看出，单道批处理系统是在解决人机矛盾和CPU与I/O设备速度不匹配矛盾的过程中形成的。换言之，批处理系统旨在提高系统资源的利用率和系统吞吐量。但这种单道批处理系统仍然不能充分地利用系统资源，故现已很少使用。 单道批处理系统的缺点系统中的资源得不到充分的利用这是因为在内存中仅有一道程序，每逢程序在运行中发出I/O请求后，CPU便处于等待状态，必须在其I/O完成后才继续运行，又因I/O设备的低速性，更使CPU的利用率显著降低。下图示出了单道程序的运行情况，从图中可以看出：在 t2～t3、t6～t7时间间隔内CPU空闲。 为了能在系统中运行较大的作业，通常在计算机中都配置了较大容量的内存，但实际情况是有80%以上的作业都输入中小型，因此在单道程序环境下，也必定造成内存的浪费。类似地，为了满足各种类型的作业需要，在系统中将会配置多种类型的I/O设备，显然在单道程序环境下也不能充分利用系统资源。 多道批处理系统（Multiprogrammed Batch Processing System）20世纪60年代中期，IBM公司生产了第一台小规模集成电路计算机IBM 360（第三代计算机系统）。由于它较之于晶体管计算机无论在体积、功耗、速度和可靠性上都有了显著的改善，因而获得了极大的成功。IBM公司为该机开发的OS/360操作系统是第一个能运行多道程序的批处理系统。 多道程序设计的基本概念为了进一步提高资源的利用率和系统吞吐量，在20世纪60年代中期引入了多道程序设计技术，由此形成了多道批处理系统。 在该系统中，用户提交的作业先存放在外存上，并排成一个队列，称为“后备队列”。然后由作业调度程序按一定的算法，从后备队列中选择若干个作业调入内存，使他们共享CPU和系统中的各种资源。由于同时在内存中装有若干道程序，这样便可以在运行程序A时，利用其因I/O操作而暂停执行的CPU空档时间再调度另一道程序B运行，即可以使多道程序交替巡幸，便可以保持CPU处于忙碌状态。 优缺点 资源利用率高 系统吞吐量大 平均周转时间长 无交互能力 需要解决的问题 处理机争用问题。既要满足各道程序运行的需要，又要提高处理机的利用率 内存分配和保护问题。系统应能为每道程序分配必要的内存空间，使他们各得其所，且不会因某道程序出现异常情况而破坏其他程序。 I/O设备分配问题。 文件的组织和管理问题 作业管理问题 用户与系统的接口问题 为此，应在计算机系统中增加一组软件，用于对上述问题进行妥善、有效的处理。这组软件应包括：能有效地组织和管理四大资源的软件、合理地对各类作业进行调度和控制他们运行的软件，以及方便用户使用计算机的软件。正是这样一组软件构成了操作系统。 据此，我们可以把操作系统定义为：操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合。 分时系统（Time Sharing System）分时系统的引入如果说推动多道批处理系统形成和发展的主要动力是提高资源的利用率和系统吞吐量，那么推动分时系统形成和发展的主要动力，则是为了满足用户对人——机交互的需求，由此形成了一种新型OS。用户的需求具体表现在以下几个方面： 人——机交互。 共享主机 由此不难得知，分时系统是指，在一台主机上连接了多个配有显示器和键盘的终端并由此所组成的系统，该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机中的资源。 分时系统实现中的关键问题在多道批处理系统中，用户无法与自己的作业进行交互的主要原因是：作业都先驻留在外存上，即使以后被调入内存，也要经过较长时间的等待后方能运行，用户无法与自己的作业进行交互。为了能够实现人——机交互，必须解决的关键问题是，如何使用户能与自己的作业进行交互。为此，系统首先必须能提供多个终端，同时给多个用户使用；其次，当用户在自己的终端上键入命令时，系统应能及时接受，并及时处理该命令，再将结果返回给用户。此后，用户可根据系统返回的响应情况，再继续键入下一条命令，此即人——机交互。亦即，允许有多个用户同时通过自己的键盘键入命令，系统也应能全部及时接受并处理。 及时接受 要做到及时接收多个用户键入的命令或数据，只需在系统中配置一个多路卡即可。例如当主机上需要连接64个终端时，就配置64个多路卡。多路卡的作用是，实现分时多路复用。即主机以很快的速度周期性地扫描各个终端，在每个终端停留很短的时间，用于接收从终端发来的数据。为了能使从终端上输入的数据被依次逐条地进行处理，还需要为每个终端配置一个缓冲区，用来暂存用户键入的命令（或数据）。 及时处理 人——机交互的关键在于，用户键入命令后，能对自己的作业及其运行及时地实施控制，或进行修改，因此，各个用户的作业都必须驻留在内存中，并能频繁地获得处理机运行。否则，用户键入的命令将无法作用到自己的作业上。由此可见，为实现人——机交互，必须彻底地改变原来批处理系统的运行方式，转而采用下面的方式 作业直接进入内存。因为作业在磁盘上是不能运行的，所以作业应直接进入内存。 采用轮转运行方式。如果一个作业独占CPU连续运行，那么其他的作业就没有机会被调度运行。为避免一个作业长期独占处理机，引入了时间片的概念。一个时间片就是一段很短的时间。系统规定每个作业每次只能运行一个时间片，然后就暂停该作业的运行，并立即调度下一个作业运行。如果在补偿的时间内能使所有的作业都执行一个时间片的时间，便可以使每个用户都能及时地与自己的作业进行交互，从而可以使用户的请求得到及时响应。 分时系统的特征 多路性 该特种是指系统允许将多台终端同时连接到一台主机上，并按分时原则为每个用户服务。多路性允许多个用户共享一台计算机，显著地提高了资源利用率，降低了使用费用，从而促进了计算机更官反的应用。 独立性 该特性是指系统提供了这样的用机环境，即每个用户在各自的终端上进行操作，彼此之间互不干扰，给用户的感觉就像是他一人独占主机进行操作。 及时性 及时性是指用户的请求能在很短时间内获得响应。这一时间间隔是根据人们所能接受的等待时间确定的，通常仅为1～3秒。 交互性 交互性是指用户可通过终端与系统进行广泛的人机对话。其广泛性表现在：用户可以请求系统提供多方面的服务，如进行文件编辑和数据处理，访问系统中的文件系统和数据库系统，请求提供打印服务等。 实时系统（Real Time System）所谓“实时”，是表示“及时”，而“实时计算”，则可以定义为这样一类计算：系统的正确性，不仅由计算的逻辑结果来确定，而且还取决于产生结果的时间。事实上实时系统最主要的特征，是将时间作为关键参数，它必须对所接受到的某些信号作出“及时”或“实时”的反应。由此得知，实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。 实时系统的类型 工业（武器）控制系统 信息查询系统 多媒体系统 嵌入式系统 实时任务的类型 周期性实时任务和非周期性实时任务 周期性实时任务是指这样一类人物，外部设备周期性发出激励信号给计算机，要求他按指定周期循环执行，以便周期性地控制某外部设备。 硬实时任务和软实时任务 硬实时任务是指系统必须满足任务对截至事件的要求，否则可能出现难以预料的结果。用于工业和武器控制的实时系统，通常执行的是硬实时任务。软实时任务也联系着一个截至时间，但并不严格。 实时系统与分时系统特征的比较 多路性 信息查询系统和分时查询系统中的多路性都表现为系统按分时原则为多个终端用户服务；实时控制系统的多路性则是指系统周期性地对多路现场信息进行采集，以及对多个对象或多个执行机构进行控制。 独立性 信息查询系统中的每个终端用户在与系统交互时，彼此相互对立互不干扰；同样在实时控制系统中，对信息的采集和对对象的控制也都是彼此互不干扰的。 及时性 信息查询系统对实时性的要求是依据人所能接受的等待时间确定的，而多媒体系统实时性的要求是，播放出来的音乐和电视能令人满意。实时控制系统的实时性则是以控制对象所要求的截至时间来确定的，一般为秒级到毫秒级。 交互性 在信息查询系统中，人与系统的交互性仅限于访问系统中某些特定的专用服务程序。它并不像分时系统那样，能向终端用户提供数据处理、资源共享等服务。而多谋体系统的交互性也仅限于用户发送某些特定的命令，如开始、停止、快进等，由系统立即响应。 可靠性 分时系统要求系统可靠，实时系统要求系统高度可靠。因此在实时系统中，往往都采取了多级容错措施来保障系统的安全性及数据的安全性。 微机操作系统的发展随着VLSI和计算机体系结构的发展，以及应用需求的不断扩大，操作系统仍在继续发展。由此先后形成了微机操作系统、网络操作系统等。 配置在微型机上的操作系统称为微机操作系统，最早诞生的微机操作系统是配置在8位微机上的CP/M。后来出现了16位微机，相应地，16位微机操作系统就应运而生，当微机发展为32位、64位时，32位、64位微机操作系统也应运而生。可见微机操作系统可按微机的字长来分，但也将它按运行方式分为如下几类： 单用户单任务操作系统 单用户多任务操作系统 多用户多任务操作系统]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程的描述与控制]]></title>
    <url>%2F2019%2F09%2F06%2F%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前驱图和程序执行程序并发执行程序的并发执行程序并发执行时的特征 间断性 失去封闭性 不可再现性进程的描述进程的定义 进程是程序的一次执行 进程是一个程序及其数据在处理机上顺序执行时所发生的活动 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位进程的特征 动态性 并发性 独立性 异步性从操作系统角度分类 系统进程 用户进程进程和程序的区别 进程是动态概念，而程序则是静态概念 程序是指令的有序集合，永远存在；进程强调是程序在数据集上的一次执行，有创建有撤销，存在是暂时的； 进程具有并发性，而程序没有 进程可创建其他进程，而程序并不能形成新的程序 进程是竞争计算机资源的基本单位，程序不是进程和程序的联系 进程是程序在数据集上的一次执行 程序是构成进程的组成部分，一个程序可对应多个进程，一个进程可包括多个程序 进程的运行目标是执行所对应的程序 从静态看，进程由程序、数据和进程控制块（PCB）组成进程的基本状态及转换 进程的三种基本状态 就绪状态ready 执行状态running 阻塞状态block 三种基本状态的转换 创建状态和终止状态 五状态进程模型 注意 阻塞态-&gt;运行态和就绪态-&gt;阻塞态这二种状态转换不可能发生挂起操作和进程状态的转换 挂起和阻塞的区别 挂起操作的目的 终端用户的需要: 修改、检查进程 父进程的需要：修改、协调子进程 对换的需要：缓和内存 负荷调节的需要：保证实时任务的执行 关键图进程管理中的数据结构 进程控制块PCB的作用 作为独立运行基本单位的标志 能实现间断性运行方式 提供进程管理所需要的信息 提供进程调度所需要的信息 实现与其他进程的同步与通信 进程控制块的信息 进程标识符 外部标识符PID 内部标识符(端口) 处理机状态 通用寄存器 指令计数器 程序状态字PSW 用户栈指针 进程调度信息 进程状态 进程优先级 进程调度所需的其他信息 事件 进程控制信息 程序和数据的地址 进程同步和通信机制 资源清单 链接指针 进程控制块的组织方式 线性方式 链接方式 索引方式进程控制操作系统内核 两大功能 支撑功能 中断管理 时钟管理 原语操作 进程的管理，由若干原语（primitive）来执行 资源管理功能 进程管理 存储器管理 设备管理 状态 系统态，管态，内核态 用户态，目态进程的创建 进程的层次结构 父进程 子进程 引起创建进程的事件 用户登录 作业调度 提供服务 应用请求 进程的创建过程 1.申请空白PCB 2.为新进程分配其运行所需的资源 3.初始化进程块PCB 4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列 进程的终止 引起进程终止的事件 1.正常结束 2.异常结束 3.外界干预 进程的终止过程 1.根据被终止进程的标识符 进程的阻塞与唤醒 引起进程阻塞和唤醒的事件 请求系统服务而未满足 启动某种操作而阻塞当前进程 新数据尚未到达 无新工作可做：系统进程 进程阻塞过程(自己阻塞自己) 进程唤醒过程(系统或其他进程唤醒自己) 进程的挂起与激活 suspend active进程同步 基本概念 两种形式的制约关系 间接相互制约关系 互斥——竞争 直接相互制约关系 同步——协作 临界资源 分区 进入区enter section 临界区critical section 退出区exit section 剩余区remainder section 同步机制应遵循的规则 1.空闲让进 2.忙则等待 3.有限等待 4.让权等待 进程同步机制 软件同步机制:都没有解决让权等待，而且部分方法还会产生死锁的情况 硬件同步机制 关中断 利用Test-and-Set指令实现互斥 利用swap指令实现进程互斥 信号量机制 整型信号量 记录型信号量 由于整型信号量没有遵循让权等待原则，记录型允许负数，即阻塞链表 AND型信号量 信号量集 理解:AND型号量的wait和signal仅能对信号施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配前，都必须测试资源数量，判断是否大于可分配的下限值，决定是否予以分配 操作 Swait(S1，t1，d1…Sn，tn，dn) Ssignal(S1，d1…Sn，dn) 特殊情况 经典进程的同步问题 生产者–消费者问题 哲学家进餐问题 读者–写者问题进程通信进程通信是指进程之间的信息交换，又称低级进程通信进程通信的类型 共享存储器系统 基于共享数据结构的通信方式 生产者和消费者 基于共享存储区的通信方式 高级通信 管道通信系统(pipe) 高级通信 消息传递系统 高级通信 方式分类 直接通信 间接通信 客服机–服务器系统消息传递通信的实现方式 直接消息传递系统 信箱通信]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据模型]]></title>
    <url>%2F2019%2F08%2F14%2F%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[test]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统概述]]></title>
    <url>%2F2019%2F07%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[数据库的4个基本概念数据(Data) 数据是数据库中存储的基本对象 定义：描述事物的符号记录。 数据种类：数字、文字、图形、图像···· 数据的含义称为数据的语义，数据与其语义不可分。 数据库(DataBase，DB)什么是数据库 数据库是长期储存在计算机内，有组织的，可共享的大量数据的集合。 为什么要建立数据库 收集并抽取一个应用所需要的大量数据，将其保存，以供进一步加工处理，抽取有用信息，转换为有价值的知识。 数据库的基本特征 数据按一定的数据模型组织，描述和存储。 可为各种用户共享，冗余度较小，易扩展。 数据独立性较高。 数据库管理系统(DataBase Management System，DBMS)什么是数据库管理系统 位于用户应用与操作系统之间的一层数据管理软件。 是基础软件，是一个大型复杂的软件系统。 用途 科学的组织和存储数据、高效地获取和维护数据。 主要功能 数据定义功能 提供数据定义语言(DDL) 定义数据库中的数据对象 数据组织、存储和管理 分类组织、存储和管理各种数据 确定数据在存储级别上的结构和存储方式 实现数据之间的联系 提供多种存取方法提高存取效率 数据操纵功能 提供数据操纵语言(DML) 实现对数据库的基本操作(增删改查) 数据库的事务管理和运行管理 数据的安全性、完整性、多用户对数据的并发操作 发生故障后的系统恢复数据库 由数据库管理系统统一管理和控制，保证事务的正确运行 数据库的建立和维护功能 提供使用程序/工具，完成数据库数据批量装载，数据库转储，介质故障恢复，数据库的重组织和性能监视等。 其他功能 数据库管理系统与网络中其他软件系统的通信 数据库管理系统之间的数据转换 异构数据库之间的互访和互操作 数据库系统(DataBase System，DBS)数据库系统 是指在计算机系统中引入数据库后的系统构成 在不引起混淆的情况下常常将数据库系统简称为数据库 数据库系统的构成 数据库 数据库管理系统 应用程序 数据库管理员(DataBase Administrator, DBA) 数据库系统的特点数据库系统的特点 数据结构化 数据的共享性高，冗余度低且易扩充 数据独立性高 数据由数据库管理系统统一管理和控制 数据结构化数据的整体结构化是数据库的主要特征之一 不再仅仅针对某一应用，而是面向整个企业或组织 不仅数据内部结构化，整体是结构化的，数据之间具有联系 数据记录可以变长 数据的最小存取单位是数据项 数据用数据模型描述，无需应用程序定义数据的共享性高，冗余度低且易扩充数据面向整个系统，可以被多个用户，多个应用共享使用数据共享的好处 减少数据冗余，节约储存空间 避免数据之间的不相容性与不一致性 使系统易于扩充 数据的独立性高物理独立性指用户的应用程序与数据库中数据的物理存储是相互独立的。当数据的物理存储发生变化应用程序不用改变 逻辑独立性指用户的应用程序与数据库的逻辑结构是相互独立的，数据的逻辑结构改变了，应用程序不用改变 数据的独立性由数据库管理系统的二级映像功能来保证。 数据由数据库管理系统统一的管理和控制数据库管理系统提供的数据控制功能 数据的安全性保护 保护数据以防止不合法的使用造成的数据的泄密和破坏。 数据的完整性检查 保证数据的正确性、有效性和相容性 并发控制 对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果 数据库恢复 将数据库从错误状态恢复到某一已知的正确状态]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统结构]]></title>
    <url>%2F2019%2F07%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[什么是数据依赖？数据依赖 数据依赖是一种完整性约束的表现形式 是通过一个关系中属性间值的相等与否体现出来的数据间的相互关系。 是现实世界属性间相互联系的抽象 数据内在的性质 是语义的体现 数据依赖的主要类型 函数依赖（Functional Dependency，FD） 多值依赖（Multivalue Dependency,MVD） 连接依赖 ··· ··· 数据依赖对关系模式的影响不合适的数据依赖，造成插入异常，删除异常，更新异常和数据冗余问题。 好的关系模式：不会产生插入异常，删除异常，更新异常，数据冗余尽可能小。 如何解决关系模式中存在的问题规范化理论–找出不合适的数据依赖，消除他们，可以在不同程度上解决插入异常，删除异常，更新异常和数据冗余。 规范化–关系的规范化理论函数依赖 定义 设R(U)是一个属性集U上的关系模式，X和Y是U 的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y 上的属性值不等，则称“X函数确定Y”或“Y函数依赖于X ”，记作X-&gt;Y X称为这个函数依赖的决定属性组，也称为决定因素。 函数依赖不是指关系模式R的某个或某些关系实例r满足的约束条件，而是指R的所有关系实例r均要满足的约束条件。 如何确定函数依赖 函数依赖是语义范畴的概念，只能根据语义来确定函数依赖 平凡函数依赖与非平凡函数依赖 X→Y，Y⊈X，则称X→Y是非平凡函数依赖 X→Y，但Y⊆X，则称X→Y是平凡函数依赖。 对于任一关系模式，平凡函数依赖都是必然成立的，他不反映新的语义，因此若不特别声明，我们总是讨论非平凡函数依赖。 完全函数依赖和部分函数依赖 定义 在关系模式R(U)中，如果X→Y，对于任意一个X的真子集X’，若X’↛Y，则称Y完全函数依赖于X。若X→Y但Y不完全函数依赖于X，则称Y部分函数依赖于X。 传递函数依赖 定义 在关系模式R(U)中，如果X→Y，Y⊈X，Y↛X，Y→Z，则称Z对X传递函数依赖。 注意，如果Y→X，即X←→Y，则Z直接依赖于X 码范式关系数据理论## 数据依赖的公理系统]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑客攻防技术宝典Web实战篇学习笔记(第三章)]]></title>
    <url>%2F2019%2F06%2F28%2F%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E5%AE%9D%E5%85%B8Web%E5%AE%9E%E6%88%98%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Web应用程序技术HTTPHTTP(HyperText Transfer Protocol，超文本传输协议)是访问互联网使用的核心通信协议，也是今天所有Web应用程序使用的通信协议。最初，HTTP只是一个为获取基于文本的静态资源而开发的简单协议，后来人们以各种形式扩展和利用他，使其能够支持如今常见的复杂分布式应用程序。 HTTP使用的是一种基于消息的模型：客户端送出一条请求消息，而后由服务器返回一条响应消息。该协议基本上不需要连接，虽然HTTP使用有状态的TCP协议作为他的传输机制，但每次请求与响应交换都自动完成，并且可能使用不同的TCP连接。 HTTP请求123456789101112GET /luong-komorebi/Awesome-Linux-Software/blob/master/README_zh-CN.md HTTP/1.1Host: github.comConnection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36DNT: 1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Referer: https://github.com/luong-komorebi/Awesome-Linux-Software/blob/master/README_zh-CN.mdAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cookie: XXX 每个请求的第一行都由以空格间隔的项目组成。 GET 第一个说明HTTP方法的动词。最常用的方法是GET，他的主要作用是从Web服务器获取一个资源，GET请求并没有消息主体，因此在消息头后的空白行中没有其他数据。 所请求的URL。该URL通常由所请求的资源名称，以及一个包含客户端向该资源提交的参数的可选查询字符串组成。 使用的HTTP版本，因特网上常用的HTTP版本为1.0和1.1，多数浏览器默认使用1.1版本，这两个版本的规范之间存在一些差异；然而当攻击Web应用程序时，渗透测试员可能遇到的唯一差异是1.1版本必须使用Host请求头。 示例中的其他要点如下： Referer消息头用于表示发出请求的原始URL。在原始的HTTP规范中，这个消息头存在拼写错误（Referrer），为了保持向后兼容就将错就错了。 User-Agent提供与浏览器或其他生成请求的客户端软件有关的信息。由于历史原因，大多数浏览器中都包含Mozilla前缀，这是因为最初占支配位置的Netscape浏览器使用了User-Agent字符串，而其他浏览器也希望让Web站点相信他们与这种标准兼容， Host消息头用于指定出现在被访问的完成URL中的主机名称。如果几个Web站点以相同的一台服务器为主机，就需要使用Host头，因为请求第一行中的URL内通常不包含主机名称。 Cookie消息头用于提交服务器向客户端发布的其他参数。 HTTP响应1234567891011121314151617181920212223HTTP/1.1 200 OKDate: Fri, 28 Jun 2019 15:24:05 GMTContent-Type: text/html; charset=utf-8Transfer-Encoding: chunkedServer: GitHub.comStatus: 200 OKVary: X-PJAXETag: W/&quot;5f75f58ae16b33849ec6b26be85e1582&quot;Cache-Control: max-age=0, private, must-revalidateSet-Cookie: user_session=s0IP-XS32pqUeAFP9UkLioZBgP3I5L_b355wOhnhDQpAVOmm; path=/; expires=Fri, 12 Jul 2019 15:24:04 -0000; secure; HttpOnlySet-Cookie: __Host-user_session_same_site=s0IP-XS32pqUeAFP9UkLioZBgP5I5L_b355wOhnhDQpwVOHm; path=/; expires=Fri, 12 Jul 2019 15:24:04 -0000; secure; HttpOnly; SameSite=StrictSet-Cookie: has_recent_activity=1; path=/; expires=Fri, 28 Jun 2019 16:24:04 -0000Set-Cookie: _gh_sess=OEJiOXdCbWxzbWhOdlhORGg4RGk0SENmY0xXUkEwZWk3VC9NODBSMnBkSGdLKzUxQzNtVnRCL2szek1TY0ZUcC9tbEN2NEtDWWZXcytvMktEVCtRSjJhUWwxQ1oxcVY4dDkyS01HQ2xHV25SZG1QYjArT0dFdzJlZEhnQ3hxOE5iTUNGYXRoemtPRG85b2lKK2pRcmtaNnBxcU9WR3BLZldleUxLL3VZLzFvSlV2ODRYRnRLU3pKaHM3TzhoZVdNTHpIWmhEMS9wWVJyWHFuV2ZqZUE5Skhsd2g0N3J6OWpxdWNOZ1RiWmI3KzBLN3c4dlRmT2lUaXh4THNFNXdPRVZJYVNjeHk3SUZvcVh6STdDVVk3cCtpeE1ycHc2Wk9kWnd4eFltODBiQ2ZFRlFJeHEvV3NNdVR4dHZ0TWpYVW01RUUzODBnYldGcjFad1hhclp5eE5pblpxUmZ1ODRPZzBRcHV2U25XZFNaPS0tY2grTWVvMlM4RG1HK1ZKQmpENGwzdz09--2e2bdb4506e83fae970965fb51403299da819ab0; path=/; secure; HttpOnlyX-Request-Id: a5a42c74-1ce0-46c0-ae29-c66bc77ede47Strict-Transport-Security: max-age=31536000; includeSubdomains; preloadX-Frame-Options: denyX-Content-Type-Options: nosniffX-XSS-Protection: 1; mode=blockExpect-CT: max-age=2592000, report-uri=&quot;https://api.github.com/_private/browser/errors&quot;Content-Security-Policy: default-src &apos;none&apos;; base-uri &apos;self&apos;; block-all-mixed-content; connect-src &apos;self&apos; uploads.github.com www.githubstatus.com collector.githubapp.com api.github.com www.google-analytics.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com wss://live.github.com; font-src github.githubassets.com; form-action &apos;self&apos; github.com gist.github.com; frame-ancestors &apos;none&apos;; frame-src render.githubusercontent.com launch-editor.github.com &apos;self&apos;; img-src &apos;self&apos; data: github.githubassets.com identicons.github.com collector.githubapp.com github-cloud.s3.amazonaws.com *.githubusercontent.com; manifest-src &apos;self&apos;; media-src &apos;none&apos;; script-src github.githubassets.com; style-src &apos;unsafe-inline&apos; github.githubassets.comContent-Encoding: gzipVary: Accept-EncodingX-GitHub-Request-Id: 14E9:7083:AC4CCA:F3DEBF:5D16310B 每个HTTP响应的第一行由3个以空格间隔的项目组成。 使用的HTTP版本。 请求结果的数字状态码。200是最常用的状态码，表示成功提交请求，成功返回资源。 一段文本形式的原因短语，进一步说明响应状态。这个短语中可包含任意值，当前浏览器不将其用于任何目的。 其他要点如下： server消息头中包含一个旗标，指明所使用的Web服务器软件，有时还包括其他信息，如所安装的模块和服务器操作系统，其中包含的信息可能并不准确。 Set-Cookie消息头向浏览器发送另一个Cookie，他将在随后向服务器发送的请求中由Cookie消息头返回。 Pragma指示浏览器不要将响应保存在缓存中，Expires消息头指出响应内容已经过期，因此不应该保存在缓存中，当返回动态内容时常常会发送这些内容，以确保浏览器随时获得最新内容。 几乎所有的HTTP响应在消息头后的空白行下面都包含消息主体，Content-Type消息头表示这个消息主体中包含一个HTML文档。 Content-Length消息头规定消息主体的字节长度。 HTTP方法GETGET方法的作用在于获取资源，他可以用于URL查询字符串的形式向所请求的资源发送参数。这使用户可以将一个包含动态资源的URL标注为标签。URL显示在屏幕上，还可以用Referer消息头将他们传送到其他站点，所以，请勿使用查询字符串传送任何敏感信息。 POSTPOST方法的主要作用是执行操作，POST方法发送的参数在body中，而不是在URL中。 后面会整理一片更详细的GET和POST区别。 除了GET和POST外，HTTP协议还支持许多其他因特殊目的而建立的方法如下： HEAD。这个方法的功能与GET相似，不同之处在于服务器不会在其响应中返回消息主体，服务器返回的消息头应与对应GET请求返回的消息头相同，因此，这种方法可用于检查某一资源在向其提交GET请求前是否存在。 TRACE。这种方法主要用于诊断，服务器应在响应主体中返回其收到的请求消息的具体内容。这种方法用于检测服务器和客户端之间是否存在任何操纵请求的代理服务器。 OPTIONS。这种方法要求服务器报告对某一特殊资源有效的HTTP方法。服务器通常返回一个包含Allow消息头的响应，并在其中列出所有有效的方法。 PUT。这个方法试图使用包含在消息请求主体中的内容，向服务器上传指定的资源。如果激活这个方法，渗透测试员就可以利用他来攻击应用程序。例如上传任意脚本并在服务器上执行。 URLURL（Uniform Resource Locator，统一资源定位符）是标识Web资源的唯一标识符，通过他即可获取其标识的资源。最常用的URL格式如下： 1protocol://hostname[:port]/[path/]file[?param=value] 如果端口号和相关协议使用的默认值不同，则只包含端口号即可，用于生成前面的HTTP请求的URL如下： 1https://mdsex.net/auth/488/YourDetails.ashx?uid=129 除这种形式外，还可以相对某一特殊主机或主机上的特殊路径指定URL，例如： 12/auth/488/YourDetails.ashx?uid=129YourDetails.ashx?uid=129 Web页面常常使用这种相对形式描述Web站点或应用程序中的导航。 URL正确的技术术语应该是URI(Uniform Resource Identifer，统一资源标识符)，但这一术语仅用于正式规范中，或被那些希望炫耀学识的人所使用。 REST表述性状态转移（REST）是分布式系统的一种体系架构，在这类体系架构中，请求和响应应包含系统资源当前状态的表述。 虽然在查询字符串中包含参数的URL本身遵循REST约束，但“REST风格的URL”一次通常指在URL文件路径而非查询字符串中包含参数的URL。例如下面这个例子： 1http://wahh-app.com/search?make=ford&amp;model=pinto 与以下包含“REST风格”参数的URL对应： 1http://wahh-app.com/search/ford/pinto 关于RESTful推荐阮一峰的博客 HTTP消息头常用消息头 Connection。这个消息头用于告诉通信的另一端，完成HTTP传输后是关闭TCP连接，还是保持连接开放以接收其他信息 Content-Encoding。这个消息头为消息主体中的内容指定编码形式，一些应用程序使用他来压缩响应以加快传输速度 Content-Length。用于规定消息主体的字节长度。（HEAD语法的响应例外，它在对应的GET请求的响应中指出主体的长度。 Content-Type。用于规定消息主体的内容类型，如HTML的内容类型为text/html Transfer-Encoding。指定为方便其通过HTTP传输而对消息主体使用的任何编码。 请求消息头 Accept。告诉服务器客户端接受哪些内容，如图像类型、办公文档格式等。 Accept-Encoding。告诉服务器客户端愿意接受哪些内容编码。 Authorization。用于为一种内置HTTP身份验证向服务器提交证书。 Cookie。向服务器提交它以前发布的Cookie。 Host。指定出现在所请求的完整URL中的主机名称。 If-Modified-Since。用于说明浏览器最后一次受到所请求的资源的时间，如果自那以后没有资源发生变化，服务器就会发出一个带状态码304的响应，指定客户端使用资源的缓存副本。 If-None-Match。用于指定一个实体标签，实体标签是一个说明消息主体内容的标识符。当最后一次收到所请求的资源时，浏览器提交服务器发布的实体标签，服务器可以使用实体标签确定浏览器是否使用资源的缓存副本。 Origin。这个消息头用在跨与Ajax请求中，用于指示提出请求的域。 Referer。用于指示提出当前请求的原始URL。 User-Agent。提高与浏览器或生成请求的其他客户端软件有关的信息。 响应消息头 Access-Control-Allow-Origin。用于指示可否通过跨与Ajax请求获取资源。 Cache-Control。用于向浏览器传送缓存指令。 ETag。用于指定一个实体标签，客户端可在将来的请求中提交这个标识符，获得和If-None-Match消息头相同的资源。通知服务器浏览器当前缓存中保存的是哪个版本。 Expires。用于向浏览器说明消息主体内容的有效时间。在这个时间之前，浏览器可以使用这个资源的缓存副本。 Location。用于在重定向响应中说明重定向的目标。 Pragma。用于向浏览器传送缓存地址。 Server。提供web服务器软件的相关信息。 Set-Cookie。用于向浏览器发布Cookie，浏览器会在随后的请求中将其返回给服务器。 WWW-Authenticate。用在带401状态码的响应中，提供与服务器所支持的身份验证类型有关的信息。 X-Frame-Options。指示浏览器框架是否及如何加载当前响应。 cookiecookie是大多数web应用程序依赖的HTTP协议的一个关键组成部分，攻击者常常通过他来利用web应用程序中的漏洞。服务器使用cookie机制向客户端发送数据，客户端保存cookie并将其返回给服务器。与其他类型的请求参数不同的，无需应用程序或用户采取任何特殊措施，随后的每一个请求都会继续重新向服务器提交cookie。 服务器使用Set-Cookie响应消息头发布cookie，cookie一般由一个名值对构成，但也可以包含不含空格的字符串。可以在服务器响应中使用几个Set-Cookie设置多个cookie，并在同一个Cookie消息头中用分号分隔不同的cookie，将他们全部返回给服务器。 除了cookie的实际值之外，Set-Cookie消息头还可以包含以下任何可选属性，用他们控制浏览器处理cookie的方式。 expires。用于设定cookie的有效时间，这样会使浏览器将cookie保存在永久性的存储器中，在随后的浏览器会话中重复利用，直到到期时间为止。如果没有定义这个属性，那么cookie仅用在当前浏览器会话中。 domain。用于指定cookie的有效域，这个域必须和收到cookie的域相同，或者是他的父域。 path。指定cookie的有效URL。 secure。如果设置这个属性，则仅在HTTPS请求中提交cookie。 Httponly。如果设置这个属性，将无法通过客户端JS 直接访问cookie。 状态码每个HTTP响应消息都必须在第一行中包含一个状态码，说明请求的结果，根据代码的第一位数字，可将状态码分为五类： 1XX —— ——提供信息 2XX —— ——请求被成功提交 3XX —— ——客户端被重定向到其他资源 4XX —— ——请求包含某种错误 5XX —— —— 服务器执行请求时遇到错误 还有大量特殊状态码，其中许多状态码只用在特殊情况下。 100 Continue。当客户端提交一个包含主体的请求时，将发送这个响应，该响应表示已收到请求消息头，客户端应继续发送主体，请求完成后，再由服务器返回另一个响应。 200 Ok。表示已成功提交请求，且响应主体中包含请求结果。 201 Created。 PUT 请求的响应返回这个状态码，表示请求已成功提交。 301 Moved Permanently。本状态码将浏览器永久重定向到另一个Location中指定的URL，以后客户端应使用新的URL代替原始URL。 302 Found。将浏览器暂时重定向到另外一个在Location中指定的URL。客户端应在随后的请求中恢复使用原始URL 304 Not Modified 。指示浏览器使用缓存中保存的所请求资源的副本，服务器使用If-Modified-Since与If-None-Match确定客户端是否拥有最新版本的资源。 400 Bad Request。本状态码表示客户端提交了一个无效的HTTP请求。当以某种无效的方式修改请求时可能会遇到这种情况。 401 Unauthorized。服务器在许可请求前要求HTTP进行身份验证，WWW-Authenticate消息头详细说明了所支持的身分验证类型。 403 Forbidden。本状态码指出，不管是否通过身分验证，禁止任何人访问被请求的资源。 404 Not Found。所请求的资源不存在。 405 Method Not Allowed。指定的URL不支持请求中所使用的方法。 413 Request Entity Too Large。如果在本地代码中探查缓冲器溢出漏洞并就此提交超常数据串，则本状态码表示请求主体过长，服务器无法处理。 414 Request Entity Too Long。表示请求中的URL过长，服务器无法处理。 500 Internal Server Error。表示服务器在执行请求时遇到错误， 503 Service Unavailable。表示尽管Web服务器运转正常，并且能够响应请求，但服务器访问的应用程序还是无法作出响应。 HTTPSHTTP代理Web功能服务器端功能客户端功能状态与会话编码方案URL编码Unicode编码HTML编码Base64编码十六进制编码远程和序列化框架下一步]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑客攻防技术宝典Web实战篇学习笔记(第二章).md]]></title>
    <url>%2F2019%2F06%2F26%2F%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E5%AE%9D%E5%85%B8Web%E5%AE%9E%E6%88%98%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[核心防御机制Web应用程序采用的防御机制 由以下几个核心因素构成。 处理 用户访 问应用程序的数据与功能, 防止用户获得未授权 访问。 处理 用户对应用程 序功能的输人 ,防止错误输人造 成不良行为。 防范攻击者 ,确保 应用程 序在成为直接攻击目标时能够正常运转,并采取适当的防御与攻击措施挫败攻 击者。 管理应用程序本身 ,帮助 管理员 监控其 行为, 配置其功能。 处理用户访问大多数 Web应用程 序使用三层相互关联的安全机制处理用户访问: 身份 验证; 会话管理; 访问 控制。 处理用户输入输入处理方法 拒绝已知的不良输入 解释：这 种方法一般使用一个 黑名单 ,其中 包含一组在攻 击中使用的已知的字 面量字符串或模式。确认机制阻止任何与黑名单匹配的数据,并接受其他数据。 缺点：这种方法是确认用户输入效率最低的方法 攻击者可 通过系列输人对典型 Web 应用程序中存在的漏洞加以利用,这些输人可通过各种方式进行编码 ,或者表现为不同的形式。除非在最简单的 情况下 .否则,黑名单可能会忽略 某些可 用于攻击 应用程序的输人模式。其次,攻击技术处在不断发展的过程之中。 当前的黑名单无法防止利用现 有漏洞 的新型方法。 通 过对被阻止的 输人稍做调整 ,即可轻易避开许多基于黑名单的过滤。例如 : -如果 SELECT 被阻止 ,则尝试SelEcT；-如果 or 1=1– 被阻止 ,则尝试or 2=2 –;-如果 alert(‘xss’)被阻止 ,则尝prompt(‘xss’);在其他情况下,通过在表达式之间使用非 标准字符破坏应用程 序执行 的令牌 ,可以避开旨在阻止特定关键字的过滤 。例如 :SELECT/* foo*/username , password/*foo*/ FROM /*foo*/users最后,各种基于黑名单的过滤,特别是 那些由web应用程 序防火 墙执行的过滤 ,都易受空字节攻击。由 于在托管和非托管情况下处理字符串的方式各 不相同,在被阻止的表达式之前的任何位 置插人空字节可能导致某些过滤器停止处 理输人 ,并 因此无 法确定表达式。例如:%00 &lt;script&gt;alert(1)&lt;/script&gt;; 接受已知的正常输入 这种方法使用一个白名单，其中包含仅与良性输入匹配的一组字符串、模式或一组标准。确认机制接受任何与白名单匹配的数据，并组织其他数据 在切实可行的情况下，这种方法是处理潜在恶意输入的最有效方法，然而许多情况下白名单并不能满足用户输入。 净化 不拒绝输入，相反，他以各种方式对输入数据进行净化，防止他造成不良影响。数据中可能存在的恶意字符被彻底删除，只留下已知安全的字符，或者在进一步处理前对他们进行适当编码或”转义” 基于数据净化的方法一般很有效，很多情况下可将其作为处理恶意输入问题的通用解法在 将危险字符植人应用程序页面前对其进行HTML编码 ,是防御跨站点脚本攻击的常 用方法(请 参阅第 12 章了解相关内容 )。然而 ,如 果箝要在一个输人项 中容纳 几种可 能的恶意数据,可能就很难 对其进行有效的净化。这时,最好采用边界确认方法处 理用户输人, 如后文所述。 安全数据处理 以不安全的方式处理用户提交的数据，是许多Web应用程序漏洞形成的主要原因。通常，不需要确认输入本身，只虚确保处理过程绝对安全，即可避免漏洞 这种方法并不适应于Web应用程序需要执行的每项任务，但如果适用，它是一种有效处理潜在恶意输入的通用方法。 语法检查 在一些 漏洞中 ,攻击 者提交的输人 与普通的非恶意用户 提交的输人完全相同 。之 所以称其为恶意输入 ,是因为攻击者提交的动机不同。例如,攻击者 可能会 修改通过隐藏表单字段提交的账号,企图访问 其他用 户的银行账户 。这时,再多的 语法确认也无法区别用户与攻击者的数据。为防止未授权访问 , 应用程 序必须 确认所 提交的账号属于之前提交该账号的用户。 边界确认服务器端应用程序的每一个单独的组件或功能单元将其输入当作来自潜在恶意来源的输入对待。除客户端与服 务器之间的外部边界外 ,应用程序在上述每 一 个信任边界上执行数据确认。这种模 型为前 面提出的问题提供了一个解决方案。每个 组件都可以防 御它收 到的特殊类型的专门设计的输入。当数据通过不同的组件时,即可对前面转换过程中生成的任意数据值执行确 认检査。而且 ,由于在不同 的处理阶段执行不同 的确认检査, 它们之间不可能发生 冲突。 多步确认与规范化 多步确认：&lt;scr&lt;script&gt;ipt&gt; 绕过对&lt;script&gt;的过滤 规范化：基于印刷字符的相似性，对字符执行最佳映射，这是《和》会被转换为&lt;和&gt;，ÿ会被转换成y等。 有时候 ,可 能很难避免多步确认与规范化造成的问题 ,也不存在解决这类问题的唯一方案。一种解决办法是递归 执行净化操作,直到 无法进 一步修改输人。然而,如果需要在净化过程中对一个存在疑问的字符进行转义 ,那么这 种情况可能会造成无限循环。通常 , 这个问题只有 根据具体情况 、基于所执行的确认类型加以解决。如果可能,最好避 免净化 某些不良输人的做法 ,完全拒绝这种类型的输人。 处理攻击者任何设计安全应用程序的开发人员必须基于这样一个假设：应用程序将成为蓄意破坏且经验丰富的攻击者的直接目标，能够以受控的方式处理并应对这些攻击，是应用程序安全机制的一项主要功能，这些机制通常结合使用一系列防御与攻击措施，以尽可能阻止攻击者，并就所发生的事件，通知应用程序所有者以及提供相应的证据。为处理攻击者而采用的措施一般由以下任务组成： 处理错误 维护审计日志 向管理员发出警报 应对攻击 处理错误应用程序的一个关键防御机制是合理地处理无法预料的错误，要么纠正这些错误，要么向用户发送适当的错误信息，在生产环境下，应用程序不应该返回任何系统生成的消息或者其他调用信息。过于详细的错误信息非常有利于恶意用户向应用程序发动进一步攻击。有些情况下，攻击者能够利用存在缺陷的错误处理方法从错误信息中获得敏感信息；此时错误信息成为攻击者从应用程序中窃取数据的重要渠道。 大多数Web开发语言通过try-catch块和受查异常提供良好的错误处理支持，应用程序代码应广泛使用这些方法查明特殊与常规错误，并做出相应处理。 有效的错误处理措施通常与应用程序的日志机制整合在一起，后者应尽可能记录与无法预料的错误有关的调试信息。通常这些无法预料的错误信息能够指明防御机制中存在的缺陷，应用程序所有者获得这些信息就能从源头解决这些问题。 维护审计日志审计日志在调查针对应用程序的入侵尝试时会发挥很大作用，发生入侵后，有效的审计日志能够帮助程序所有者了解实际发生的情况，如哪些漏洞被利用，攻击者是否可以对数据进行非法访问或执行未授权操作，并尽可能提供入侵者的身份信息。 日志应记录所有重要事件，一般这些事件应至少包括以下几项： 所有与身份验证功能有关的事项，如成功或失败登录，修改密码等。 关键交易，如支付、转账。 被访问控制机制阻止的访问企图。 任何包含已知攻击字符串，公然表明恶意企图的请求。 有效 的审计日志功能一般 会记录 每个事 件的发生时间 、发出请求的 地址 和用户的账户(如果通过验证)这些日志必须受到严格保护 . 避免未授权的读取或写人访问。一种有效的保护方法是将审计日志保存在仅接受主应用程序送出的更新消息 的自治系统中 。某些 情况下,可能 需要将日志复制到一次性写人的媒质中,确保它们的完整性 ,以便在遭 受攻击后进行 调査。 在 受攻击 面方面 ,保护不严密的审计日志可能为攻击者提 供大量 信息,向其披露许多敏感信息,如会话令牌和请求参数,这些信息可能会使攻击者能够立即攻破整个应用程序 向管理员发出警报在任何安 全性至关重要的应用程序中,进行实时警报的最有效方法是将其与应用程序的输人确认机制和其他控制方法紧密结合起来。应用程 序的主要防御机制应阻止攻击,而且 ,这些保护机制可轻易与应用程序 的替报机制进 行整合 ,提供完全自定义的恶意行为警示。 应对攻击一些 应用程序采取自动反应措施阻止攻 击者进行这种 形式的探査,例如对 攻击者提 交的请求的响应速度 变得越来越慢 ,或者终止攻击者的会话 ,要求其重新登录或 在继续 攻击前执行其他步驟。虽然这些措施无法阻挡最有 耐心和 决心的攻击者 ,但能够阻止许多 很随意的攻击者 ,并且为管理员监控此类 情况、在必要 时采取更加严厉的措施贏得时间。给攻击者 设置更 多阻碍是一种有效的深层防御措施 ,这 样做能 够降低 任何残存的漏洞被发现和利用的可能性。 杂项及拓展 SSL（128位安全套接层）：是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理]]></title>
    <url>%2F2019%2F06%2F24%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Principle-of-Computer-Composition计算机组成原理思维导图 计算机组成第一章 计算机系统概论冯诺依曼型计算机特点 1.计算机由运算器，控制器，存储器，输入和输出设备5部分组成 2.采用存储程序的方式，程序和数据放在同一个存储器中，并以二进制表示。 3.指令由操作码和地址码组成 4.指令在存储器中按执行顺序存放，由指令计数器(即程序计数器PC)指明要执行的指令所在的储存单元地址，一般按顺序递增，但可按运算结果或外界条件而改变 5.机器以运算器为中心，输入输出设备与存储器间的数据传送都通过运算器区别以运算器为中心的计算机还是存储器的方法 看输入设备能否直接与存储器相连，是的话就是以存储器为中心计算机系统 硬件 结构 主机 cpu ALU运算器 CU控制器 存储器 主存 辅存 I/O 输入设备 输出设备 主要技术指标 机器字长 CPU一次能处理的数据位数 存储容量 存储容量＝存储单元个数×存储字长 运算速度 单位时间执行指令的平均条数，MIPS 软件 系统软件 用来管理整个计算机系统 语言处理程序 操作系统 服务性程序 数据库管理系统 网络软件 应用软件 按任务需要编制成的各种程序第三章 运算方法和运算部件数据的表示方法和转换 机器数正0负1 符号数值化的带符号二进制数，称为机器数。 真值:符号位加绝对值 余三码:在8421码的基础上，把每个编码都加上0011 当两个余三码想加不产生进位时，应从结果中减去0011;产生进位时，应将进位信号送入高位，本位加0011 格雷码:任何两个相邻编码只有1个二进制位不同，而其余3个二进制位相同 8421码 权值从高到低为8、4、2、1 算术运算时，需对运算结果进行修正。 方法：如果小于、等于(1001)2，不需要修正；否则加6修正带符号的二进制数据在计算机中的表示方法及加减法运算 原码 定义 最高位为符号位0/1+数值的绝对值形式 特点 （1）值+0，-0的原码分别为00000、10000，形式不唯一； （2）正数的原码码值随着真值增长而增长 负数的原码码值随着真值增长而减少 （3）n+1位原码表示定点整数范围－(2n－1)——2n－1 n+1位原码表示定点小数范围 －(1－2－n)——1－2－n 运算 绝对值相加减，由数值大小决定运算结果符号 补码 定义，特点和运算 运算:结果不超过机器所能表示范围时，[X+Y]补=[X]补+[Y]补减法运算:[X–Y]补=[X+(–Y)]补=[X]补+[–Y]补 结论 负数的补数＝模＋负数 互为补数的绝对值相加＝模 在补数中，减法运算即加法运算 定义 定义法，即[X]补=2·符号位+X （MOD 2） X为正数，则符号0+X的绝对值；X为负数，则X的绝对值取反+1。 特点 数值零的补码表示唯一 正数补码码值随着真值增大而增大，负数补码码值随着真值增大而增大 n+1位补码所表示定点整数范围－ 2n——2n－1，n+1位补码所表示定点小数范围－1——1－2－n 加法运算逻辑事例 过程 加减法运算的溢出处理 溢出定义 当运算结果超出机器数所能表示的范围 加减中，可能产生溢出的情况 可能出现溢出 同号数相加 异号数相减 不可能出现溢出 异号数相加 同号数相减 判断溢出的方法 法一：当符号相同两数相加，结果符号和加数（或被加数）不相同，则溢出 fa,fb表示两操作数（A,B）的符号位,fs为结果的符号位 法二：任意符号相加，如果C=Cf，则结果正确，否则溢出； C为数值最高位的进位，Cf为符号位的进位 法三：采用双符号相加，如果fs1=fs2，则结果正确，否则溢出； 运算结果的符号位为fs2； 多符号位的补码，叫做变形补码； 如果采用双符号位，当数为小数时，模m=4;当数为整数时，模m=2的n+2次方 反码 定义 a.定义法，即[X]反=(2-2-n)·符号位+X (MOD 2-2-n) b.X是正数，[X]反=[X]原；X是负数，符号+数值取反。 特点 数值零的反码表示不唯一 正数反码码值随着真值增大而增大，负数反码码值随着真值增大而增大 n+1位反码所表示定点整数范围－ (2n－1)——2n－1，n+1位反码所表示定点小数范围－(1－2－n)——1－2－n 加减运算特点 在机器数范围内，反码运算满足[X+Y]反=[X]反+[Y]反，[X－Y]反=[X]反+[－Y]反 反码运算在最高位有进位时，要在最低位+1，此时要多进行一次加法运算，增加了复杂性，又影响了速度，因此很少采用 由于反码运算是以2-2的-次方为模，所以，当最高位有进位而丢掉进位(即2)时，要在最低位+/-1 移码 由来及窍门 为了从码值直接判断对应真值的大小，所以引进移码 [X]补的符号位取反，即得[X]移 特点 最高位是符号位，1表示正，0表示负 数据0有唯一的编码 移码码值随着真值增大而增大 n+1位移码所表示定点整数范围－ 2n——2n－1， n+1位移码所表示定点小数范围－1——1－2－n 计算机中，移码常用于表示阶码，故只执行加、减运算 计算机中，移码运算公式需要对结果进行修正 浮点数的阶码运算 移码定义:[X]移=2的n次方+X 补码定义:[X]补=2的n+1次方+Y 阶码求和公式 [X]移+[Y]补=[X+Y]移 mod2的n+1次方 [X]移+[-Y]补=[X-Y]移 判溢方法 双符号位参加运算，最高符号位恒置0 当结果最高符号位=1则溢出 低位符号=0，则上溢；低位符号=1，则下溢； 当结果最高符号位=0则未溢出 低位符号=0，负数；低位符号=1，正数 说明:如果阶码运算的结果溢出，上述条件不成立。此时，使用双符号位的阶码加法器，并规定移码的第二个符号位，即最高符号位恒用0参加加减运算，则溢出条件是结果的最高符号位为1。此时低位符号为0时，表明结果上溢;为1时，表明结果下溢。当最高符号位为0时，表明没有溢出，低位符号位为1，表明结果为正;为0时表明结果为负。 补，反，原，移码的相互转换 反码-》原码 方法：符号位不变，正数不变，负数数值部分取反。 补码-》原码 方法1：正数不变，负数数值部分求反加1。 方法2：串行转换 从最后开始数，遇到第一个“1”，除第一个“1”不变，前面数字分别取反 移码-》原码 方法：移码转换为补码，再转换为原码 数据从补码和反码表示形式转换成原码 自低位开始转换，从低位向高位，在遇到第一个1之前，保存各位的0不变，第一个1也不变，以后得各位按位取反，最后保持符号位不变，经历一遍后，即可得到补码 定点数和浮点数 定点数 小数点固定在某个位置上的数据 32位定点小数、定点整数补码的范围 32位定点小数-1～1-2-31 32位定点整数-231～231-1 浮点数 根据IEEE754国际标准，常用的浮点数有两种格式 Nmax=Mmax2的EmaxNmin=Mmin2的Emax 单精度(32位)=8位阶码+24位尾数 单精度浮点数(32位)，阶码8位(含一位符号位)，尾数24(含一位符号位)，取值范围:-2的127次方～(1-2的-23次方)*2的127次方 双精度(64位)=11位阶码+53位尾数 双精度浮点数(64位)，阶码11位(含一位符号位)，尾数53位(含一位符号位)，取值范围:-2的1023次方～(1-2的-52次方)*2的1023次方 为了保证数据精度，尾数通常用规格化形式表示:当R=2，且尾数值不为0时，其绝对值应大于或等于(0.5)10 左规 右规 小数点位置可以浮动的数据。 表示形式：N = M · RE 计算机中存储形式 Ms+Es+E(n位)+M(m位) 阶码E，一般为整数，用补码或者移码表示； 尾数M，一般为规格化的定点小数，用补码表示；二进制乘法运算 定点原码一位乘法 两个原码数相乘，其乘积的符号为相乘两数符号的异或值，数值则为两数绝对值之积 [X·Y]原=[X]原·[Y]原=(X0⊕Y0)|(X1X2..Xn) · (Y1Y2..Yn) 几点结论 从低到高根据乘数每位0、1决定相加被乘数还是0； 相加数每次左移，最后一起求积； 符号由异或决定 表达式 电路框架 修正 1.在机器内多个数据一般不能同时相加，一次加法操作只能求出两数之和，因此每每求得一个相加数，就与上次部分积相加 2.人工计算时，相加数逐次向左偏移一位，由于最后的乘积位数是乘数(或被乘数)的两倍，如按此算法在机器中运算，加法器也需增到两倍。观察计算过程很容易发现，在求本次部分积时，前一次部分积的最低位不再参与运算，因此可将其右移一位，相加数可直送而不必偏移，于是用N位加法器就可实现两个N位数相乘 部分积右移时，乘数寄存器同时右移一位，这样可以用乘数寄存器的最低位来控制相加数(取被乘数或零)，同时乘数寄存器的最高位可接受部分积右移出来的一位，因此，完成乘法运算后，A寄存器中保存乘积的高位部分，乘数寄存器中保存乘积低位部分 例题 控制流程图 定点补码一位乘法 表达式 [X·Y]补=[X]补·(－Y0+Y1·2-1+….Yn·2-n) 注意：此处为双符号位，当最后乘积高位为负数时，需要补充加上[-|x|]补的操作二进制除法 加减交替法 当余数为正时，商上1，求下一位商的办法是，余数左移一位，再减去除数;当余数为负时，商上0，求下一位商的办法是，余数左移一位，再加上除数。此方法不用恢复余数，所以又叫不恢复余数法。但若最后一次上商为0而又需得到正确余数，则在这最后扔需恢复余数浮点数的运算方法 浮点数的加减法运算 1.对阶操作 求出△E，再对小的进行移位 2.尾数的加减运算 3.规格化操作 规则简化是符号位和数值最高位不同，即00.1xxxx或11.0xxxx 4.舍入 超出表示范围的高位为1舍入 5.检查阶码是否溢出 浮点数的乘除法运算 1.浮点数阶码运算(移码) 牢记公式 [X+Y]移=[X]移+[Y]补 [X–Y]移=[X]移+[–Y]补 2.按照一位乘或加减交替除运算 先确定符号，在列式子计算运算部件 ABC寄存器作业 定点运算部件 浮点运算部件 由阶码运算部件和尾数运算部件组成数据校验码 码距 任意两个合法码之间不相同的二进制位数的最小值 要具有差错能力，则码距&gt;1 合理增大码距，就能提高发现错误的能力 鉴定方法 有无差错能力 是否能合理增大码距 奇偶校验码 能发现数据代码中一位或奇数个位出错情况的编码 实现原理是使码距由1增加到2 步骤1：在字节高位补充一位，即校验位 步骤2：依据图3.10电路形成原始数据D8..D1的校验位值 步骤3：将9位数据写入主存 步骤4：读出该数据时，读取数据D8..D1通过图3.10判定合法性 电路图 结论 （1）奇偶校验码只能发现一位或奇位错，且不能确定出错位置 （2）奇偶校验码的码距=2 海明校验码 海明码位号和校验位位号的关系 Pi的位置在2的i-1次方，但是除了最高位 笔记 3,5,7||3,6,7||5,6,7 电路图 海明码码距为4 纠一位错，查一位错 2∧r≥k+r+1 纠一位错，查两位错 2∧(r–1)≥k+r 循环冗余校验码(CRC) CRC码可以发现并纠正信息存储或传送过程中连续出现的多位错误 CRC码一般是指k位信息码之后拼接r位校验码 模2运算 模2加减 模2乘除 异或逻辑 CRC的译码与纠错 更换不同的待测码字可以证明:余数与出错位的对应关系是不变，只与码制和生成多项式有关 图第四章 主存储器主存储器处于全机中心低位辅助存储器或称为外存储器，通常用来存放主存的副本和当前不在运行的程序和数据主存储器的类型 随机存储器RAM 非易失性存储器主存储器的主要技术指标 主存容量 64×8等等 计算机可寻址的最小信息单元是一个存储字 主存储器存储单元的总数 存取速度 由存储器存取时间和存储周期表示 存储器存取时间 启动一次存储器操作(读/写)到完成该操作所经历的时间 存储周期 连续启动两次独立的存储器操作所间隔的最小时间主存储器的基本操作 CPU通过使用AR(地址寄存器)和DR(数据寄存器)和主存进行数据传送 若AR为K位字长，DR为n位字长，则允许主存包含2∧k个可寻址单元 CPU与主存采取异步工作方式，以ready信号表示一次访存操作的结束读/写存储器 随机存储器(RAM)按存储元件在运行中能否长时间保存信息分为静态存储器和动态存储器 静态存储器，利用触发器保存信息，只要不断电，信息就不会丢失 电路简图 MOS静态存储结构图 动态存储器，利用MOS电容存储电荷来保存信息，需要不断给电容充电才能使信息来保存信息 电路简图 16K×1位动态存储器框图 再生 集中式 分散式 时间小于或等于2ms 行读出再生非易失性半导体存储器 只读存储器ROM 只读不能写 可编程序的只读存储器PROM 一次性写入 可擦可编程序的只读存储器EPROM 可多次写入、读出 可电擦可编程序只读存储器E2PROM 可多次读出但写入次数有限 快擦除读写存储器Flash Memory 重复写入、读出存储器的组成与控制 存储器容量扩展 位扩展:用多个存储器芯片对字长进行扩充 字扩展:增加存储器中字的数量，提高存储器的寻址范围 字位扩展，假设一个存储器的容量为M×N位，若使用L×K位存储器芯片，那么，这个存储器共需要(M/L)×(N/K)个存储器芯片多体交叉存储器 提高访存速度的方式 采用高速器件 采用层次结构 调整主存结构 计算机中大容量的主存可由多个存储体组成，每个存储体都具有自己的读写线路，地址寄存器和数据寄存器，称为”存储模块”。这种多模块存储器可以实现重叠与交叉存取 第i个模块M的地址编号应按下式给出:M×j+i 连续地址分布在相邻的不同模块内，而同一模块内的地址都是不连续的第五章:指令系统指令系统的发展 20世纪70年代末人们提出了便于VLSI实现的精简指令系统计算机，简称RISC，同时将指令系统越来越复杂的计算机称为复杂指令系统计算机，简称CISC指令格式 结构(操作码+地址码) 操作码 操作数的地址 操作结果的存储地址 下一条指令的地址 地址码 零地址指令 一地址指令 寻址范围 224 = 16 M 2次访存 二地址指令 寻址范围 212 = 4 K 4 次访存 三地址指令 寻址范围 28 = 256 4 次访存 多地址指令 寻址范围 26 = 64 4 次访存 指令字长 取决因素 操作码的长度 操作数地址的长度 操作数地址的个数 指令字长 固定 指令字长 = 存储字长 指令字长 可变 按字节的倍数变化 对准边界存放 不连续存放数据 按字节编址 a.半字地址最低位恒为0 b.字地址最低两位恒为0 c.双字地址的最低三位恒为0 减少访存次数，浪费存储空间 不 对 准 边 界 存 放 连续存放数据 节约存储器空间，但增加访存次数，对多字节数据存在调整高 低字节位置的问题 寻址方式 确定本条指令的数据地址 下一条要执行的指令地址的方法 指令操作码的扩展技术 指令操作码的长度决定了指令系统中完成不同操作的指令数 若某机器的操作码长度固定为K位，则它最多只能有2^K条不同指令 指令操作码两种格式 固定格式 优点:对于简化硬件设计，减少指令译码时间非常有利 缺点:指令少，浪费地址 可变格式(分散地放在字的不同字段) 优点:指令多，缩短指令平均长度，减少程序总位数，增加指令字所能表示的操作信息 缺点:译码复杂，控制器的设计难度增大 拓展方法的一个重要原则 使用频度(即指令在程序中出现概率)高的指令应分配短的操作码，使用频度低的指令相应地分配较长的操作码 指令系统的兼容性 保持系统向上兼容精简指令系统计算机（RISC）——用于小型机复杂指令系统计算机（CISC）——用于大型机第六章：中央处理器计算机工作过程 加电——》产生reset信号——》执行程序——》停机——》停电 产生reset信号的任务 任务一：使计算机处于初始状态 任务二：从PC中取出指令地址 控制器作用是协调并控制计算机各部件执行程序的指令序列控制器的组成 控制器的功能 取指令 发出指令地址，取出指令的内容 分析指令 （1）对操作码译码产生操作相应部件的控制信号 （2）根据寻址方式形成操作数地址 执行指令 （1）根据分析指令后产生控制信号、操作数地址信号序列，通过CPU及输入输出设备的执行实现每条指令的功能 （2）结果回送存储器 （3）形成下条指令的地址 控制程序和数据的输入和结果输出 对异常情况和某些请求的处理 异常情况的处理：例如算术运算的溢出、数据传送奇偶错 某些请求的处理 “中断请求”信号 DMA请求信号 控制器的组成 程序计数器（PC） 即地址寄存器，用来存放当前正在执行的指令地址或即将要执行的下一条指令地址 指令寄存器（IR） 用以存放当前正在执行的指令，以便在指令执行过程中控制完成一条指令的全部功能 指令译码器或操作码译码器 对指令寄存器中的操作码进行分析解释，产生相应的控制信号 脉冲源及启停线路 脉冲源参数一定评率的脉冲作为整个机器的时钟脉冲，是机器周期和工作脉冲的基准信号，在机器刚加电时，还应产生一个总清信号（reset） 时序控制信号形成部件 当程序启动后，在CLK时钟作用下，根据当前正在执行的指令的需要，产生相应的时序控制信号，并根据被控制功能部件的反馈信号调整时序控制信号 控制存储器 微指令寄存器 控制字段+下址 周期概念 指令周期 完成一条指令所需的时间，包括取指令、分析指令、执行指令 机器周期 也称为CPU周期，是CPU从内存中读取一个指令的时间，通常等于取指周期 时钟周期 称为节拍脉冲或T周期，是基准脉冲信号 三条假设 程序是存放在主存中的，当执行完一条指令后才从主存中取下一条指令（非流水线） 指令的长度是固定的，并限制了寻址方式的多样化 在程序运行前，程序和数据都已存在主存中 指令执行过程（运算器和控制器配合） 组成控制器的基本电路 具有记忆功能的触发器以及由它组成的寄存器，计数器和存储单元 没有记忆功能的门电路及由它组成的加法器，算术逻辑运算单元（ALU）和各种逻辑电路 举例 加法 取指令——》计算操作数地址——》取操作数——》执行结果并运算送结果 要能看懂时序图 哪些指令在对应的时间有效 条件转移指令 取指令——》计算地址 控制器的功能就是按每一条指令的要求产生所需的控制信号 产生控制信号的方法 微程序控制 硬布线控制微程序控制计算机的基本工作原理 基本概念 微指令 在微程序控制的计算机中，将由同时发出的控制信号所执行的一组微操作 微命令 将指令分为若干条微指令，按次序执行这些微指令。组成微指令的操作即微命令 微程序 计算机的程序由指令序列构成，而计算机每条指令的功能均由微指令序列解释完成，这些微指令序列的集合就叫做微程序 控制存储器 微程序一般是存放在专门的存储器中的，由于该存储器主要存放控制命令（信号）与下一条执行的微指令地址（简称下址） 存储单元内容 （1）微指令的控制信号——控制位 （2）下条微指令的地址——下址字段 存储芯片：ROM 执行一条指令实际上就是执行一段存放在控制存储器中的微程序 实现微程序控制的基本原理 控制信号（23条） 书上P123页为加法的过程 微指令格式：控制字段+下址字段 23个控制位，12个下址位——》容量为4K 取址微指令的操作对所有指令都是相同的，所以是一条公用的微指令，其下址由操作码译码产生 微程序控制器 时序信号及工作脉冲的形成 停机和停电的区别 停机 电压：稳定 存放内容：保持 重启PC内容：断点指令地址 停电 电压：消失 存放内容：RAM的内容消失 重启PC内容：第一条指令地址微程序设计技术 如何缩短微指令字长 直接控制法（容量太小） 编译方法：每一位代表一个控制信号，直接送往相应的控制点 优点：控制简单 缺点：微指令字长过大 字段直接编译法 选出互斥的微指令 每个字段都要留出一个代码，表示本段不发出任何指令（000） 优点：节省微指令的字长 缺点：增加了额外的硬件开销 字段间接编译法 指令之间相互联系的情况 举例：A为0-7，B为0-3，如果是直接编译——3+2=5，如果是间接编译——3+1=4 编码方法：在字段直接编译法中，译码输出端要兼由另一字段中的某些微命令配合解释 优点：减少了微指令长度 缺点：可能削弱微指令的并行控制能力，同时增加硬件开销 常熟源字段E(了解) 如何减少微指令长度 现行微指令/微地址 现行微指令：当前正在执行的指令 现行微地址：存放现行微指令的控制器存储单元 后继微指令/微地址 后继微指令：下一条要执行的微指令 后继微地址：存放后继微指令的控制器存储单元 增量与下址字段结合产生后继微指令的方法 下址字段分成：转移控制字段BCF和转移地址字段BAF BCF：控制微程序的转移情况 BAF：转移后的微指令所在地址 BAF有两种情况 与uPC的位数相等——转移灵活，但增加微指令长度 比uPC短——转移地址收到限制，但可缩短微指令长度 优点 微指令的下址字段很短，仅用于选择输入uPC计数器的某条线路有效 缺点 微程序转移不灵活，使得微程序在控存中的物理空间分配有困难 多路转移方式 一条微指令存在多个转移分支的情况称为多路转移 微中断 1.微中断请求信号是由程序中断请求信号引起的 2.在完成现行指令的微程序后响应该微中断请求 3.由硬件产生对应微中断处理程序在控存中的入口地址 如何提高微程序的执行速度 微指令格式 水平型微指令——直接控制，字段编译（直接、间接） 特点：在一条微指令中定义并并行执行多个微命令 垂直型微指令 特点：不强调实现微指令的并行控制功能 定义：采用微操作码编译法，由操作码规定微指令的功能 微程序控制存储器 一般采用ROM存储器 也可采用RAM，为防止断电后内容消失，则必须开机后将外存中存放的微程序调入控存RAM，然后才能执行程序。 当前为了能不断扩展指令系统，通常采用ROM+RAM 动态微程序设计 定义：能根据用户要求改变微程序 优点：是计算机能更灵活、有效的适应于各种不同的应用目标 控制存储器的操作（P136） 串行方式 并行方式——比串行多了微指令寄存器 微周期=max(取微指令时间,执行微指令时间) 由于取微指令、执行微指令同时进行，故对于某些后继微地址的产生根据处理结果而定的微指令，则延迟一个微周期再取微指令硬布线控制的计算机（RISC）——特点快 形成操作控制信号的逻辑框图（P141） 操作控制信号的产生 取值周期cy1所产生的信号对所有指令都是相同的，即与当前执行的指令无关，逻辑式得到最简单的形式 通常，同一个控制控制信号在若干条指令的某些周期（或再加上一些条件）中都需要，为此需要把它们组合起来 同种类型的指令所需要的控制信号大部分是相同的，仅有少量区别 在确定指令的操作码时（即对具体指令赋予二进制操作码），为了便于逻辑表达式的化简以减少逻辑电路数量，往往给予特别关注 设计组合逻辑电路从而产生需要的控制信号的步骤 1.实际逻辑问题2.真值表3.公式化简4.逻辑电路图 设计目标 使用最少的电路元件达到最高的操作速度流水线工作原理 几点结论 每条指令的执行时间不变 每条指令处理结果的时间缩短 流水线处理速率最高时=流水线处于满载的稳定状态 流水线处理速率最低时=流水线未满载状态 为了满足在重叠时间段不同指令的机器周期能够完成指定的操作，将时间段=操作完成的最长时间 为了保证一个周期内流水线的输入信号不变，相邻时间段之间必须设置锁存器或寄存器 除了指令执行流水线，还有运算操作流水线 相关问题 流水线阻塞（P163-6.15） 数据相关产生 假设第二条指令需要的操作数是第一条指令运算的结果，那么出现了数据相关 指令执行时间不同产生 程序转移的影响 异常情况响应中断第七章：存储系统存储系统的层次结构 cache-&gt;主存-&gt;辅存高速缓冲存储器 cache的工作原理 局部性原理 主存地址和cache地址（P166 图7.2） 块长 块长一般取一个主存周期所能调出的信息长度（一般为16个字） cache的容量和块的大小是影响cache的效率的重要因素 命中率 CPU所要访问的信息是否在cache中的比率，而将所要访问的信息不在cache中的比率称为失败率 一致性策略 标志交换方式（写回法） 通过式写入（写通法） 写操作直接对主存进行，而不写入cache cache的存取时间 平均存取时间=h*tc+(1-h)(tc+tm) 最好替换策略 按照被替换的字块是下一段时间最少使用的，由替换部件实现 cache组织 地址映像 直接映像 cache中许多空的位置被浪费 主存地址：主存字块标记+cache字块地址+字块内地址 全相联映像 成本太高而不能采用 主存地址：主存字块标记+字块内地址 优点 方式灵活，缩小了块发生冲突的概率 缺点 增加了标识位位数 增加了寻找主存块在cache中对应块的时间 组相联映像 直接映像和全相联映像的折衷 主存地址：主存字块标记+组地址+块内地址虚拟存储器 存储管理部件（MMU） 现代计算机一般都有辅助存储器，但具有辅存的存储系统不一定是虚拟存储系统 虚拟存储系统的特点 允许用户程序用比主存大的多的空间来访问主存 每次访存都要进行虚实地址的转换第八章：辅助存储器半导体存储器可随机访问任一单元，而辅助存储器一般为串行访问存储器辅助存储器的种类 磁表面存储器 数字式磁记录 硬盘、软盘和磁带 模拟式磁记录 录音、录像设备 光存储器 光盘串行存储器 顺序存取存储器 直接存取存储器辅助存储器的技术指标 存储密度 定义：单位长度或单位面积磁层表面磁层所存储的二进制信息量 道密度 沿磁盘半径方向单位长度的磁道数称为道密度，单位为道/英寸tpi或道/毫米tpmm 位密度或线密度 单位长度磁道所能记录二进制信息的位数叫位密度或线密度，单位为位/英寸bpi或位/毫米bpmm 每个磁道所存储的信息量是一样的 存储容量 C = n × k × s 寻址时间 平均寻址时间Ta=平均找道时间Ts+平均等待时间Tw 辅存的速度 寻址时间 磁头读写时间 数据传输率 Dr = D × V 误码率 价格硬磁盘存储器的类型 (1) 固定磁头和移动磁头 (2) 可换盘和固定盘磁盘存储器 温彻斯特磁盘简称温盘 磁盘存储器由驱动器（HDD），控制器（HDC）和盘片组成 最外面的同心圆叫0磁道，最里面的同心圆假设称为n磁道 驱动器的定位驱动系统实现快速精准的磁头定位 主轴系统的作用是带动盘片按额定转速稳定旋转 数据控制系统的作用是控制数据的写入和读出，包括寻址，磁头旋转，写电流控制，读出放大，数据分离 磁盘控制器有两个方向的接口 与主机的接口 与驱动器（设备）的接口光盘 采用光存储技术 利用激光写入和读出 第一代光存储技术 采用非磁性介质 不可擦写 第二代光存储技术 采用磁性介质 可擦写 光盘的存储原理 只读型和只写一次型 热作用（物理或化学变化） 可擦写光盘 热磁效应第九/十章：输出输出（I/O）设备/系统设备控制器（I/O）的基本功能 实现主机和外部设备之间的数据传送 实现数据缓冲，以达到主机同外部设备之间的速度匹配 接受主机的命令，提供设备接口的设备，并按照主机的命令控制设备I/O 编址方式 (1) 统一编址：用取数、存数指令 (2) 不统一编址：有专门的 I/O 指令I/O 与主机的连接方式 辐射式连接 每台设备都配有一套 控制线路和一组信号线 不便于增删设备 总线连接 便于增删设备I/O设备 人机交互设备 键盘、鼠标等 计算机信息的驻留设备 硬盘、光盘等 机——机通信设备 MODEN等为什么要设置接口？ 实现设备的选择 实现数据缓冲达到速度匹配 实现数据串 并格式转换 实现电平转换 传送控制命令 反映设备的状态 （“忙”、“就绪”、“中断请求”）中断服务程序的流程 (1) 保护现场 程序断点的保护 寄存器内容的保护 (2) 中断服务 对不同的 I/O 设备具有不同内容的设备服务 (3) 恢复现场 出栈指令 (4) 中断返回 中断返回指令单重中断和多重中断 单重 中断 不允许中断 现行的 中断服务程序 多重 中断 允许级别更高 的中断源 中断 现行的 中断服务程序DMA 方式 主存和 I/O 之间有一条直接数据通道 CPU 和 I/O 并行工作 DMA 的三种工作方式 (1) CPU暂停方式 (2) CPU周期窃取方式 (3)直接访问存储器 DMA 接口功能 (1) 向 CPU 申请 DMA 传送 (2) 处理总线 控制权的转交 (3) 管理 系统总线、控制 数据传送 (4) 确定 数据传送的 首地址和长度，修正 传送过程中的数据地址和长度 (5) DMA 传送结束时，给出操作完成信号 DMA 传送过程 预处理、数据传送、后处理外设接口 设备与主机相连时，必须按照规定的物理互连特性、电气特性等进行连接，这些特性的技术规范称为接口标准]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Quartus II安装破解及基础操作]]></title>
    <url>%2F2019%2F06%2F03%2FQuartus-II%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Quartus II安装破解及基础操作安装了hexo之后第一篇博客本来是python爬虫的，结果在问题复现的时候自己的ip被封了，途中也发现有其他的方法，所以耽误了一段时间，才写了一半，争取尽快写完发出来。 第一次写博客，感觉肚子里没点墨水还真是不行，那就从小的知识开始写吧 为了能够在周四给老师交作业的时候不忘记步骤掉链子，以及方便以后用的时候再看，这次就先是今天Quartus使用的简单记录。 安装破解 安装 安装包以及破解要使用的工具已经放[某云盘](链接: https://pan.baidu.com/s/1Un_7PJ8mWCU9o5GOtCJf9w 提取码: 5v0x)了，自行取用。 安装很简单，打开安装程序，除中间可自行选择安装路径(安装路径后面用的到)外，其余一路next下来就好，就不再多说。 破解在破解器压缩包里，提供了32位和64位电脑用到的破解软件，这里以64位为例。解压然后将其中的可执行文件复制到 安装路径下\quartus\bin64 例如我的在E:\altera\13.0sp1\quartus\bin64 文件位置不对的话会出现这样一个提示 OK现在要关掉电脑的杀毒软件，否则的话会被当成病毒清理掉，打开破解程序，点击应用，保存license.dat文件退出即可 打开安装好的Quartus，选择第二项 Tools-&gt;license setup 在下面network Interface····复制第一个(第一个逗号之前的)出来，用sublime打开刚才的license文件，替换下图中的XXX 保存关闭重启，破解就完成了。破解之后在刚才的license setup中我们看到,可以用的2035年嘻嘻嘻。 破解就结束了。 其实很多带有试用期的软件像PHP storm这种还有一个更加简单的破解方法。那就是在打开软件选在30天适用之前修改系统时间，然后再选择适用，那么试用期就会到你定的时候开始适用一段时间。 例如我们选择试用期之前把系统时间改成2099.1.1，那么三十天试用期的截至时间就是2099.2.1 嘿嘿嘿···· 使用 原件建模及连接这次作业做的是累加器（计数器？）+ALU，累加器从0-15，输出结果连到ALU的S端。 第一个问题就是怎么把两个模块连起来呢？ 不绕圈子了·····字实在太多了，现在已经半夜12点了····· 在项目中新建一个Verilog HDL file 写出原件对应的代码，如一个简单的累加器代码如下 代码写完点击Processing下面的Analysis Current File，成功之后在左边的文档树中找到这个文件右键选择倒数第二个 这样一个原件就出来了，找到ALU的bdf文件打开，在空白处双击，在project下选择元件的模块名称，ok放到对应位置即可。这样两个元件就联系起来了。 仿真电路图连接好之后就需要仿真，首先得编译，选择processing下面的start compilation或者上面的符号开始编译。 等待编译成功后新建一个vwf file,在左侧空白处双击， 然后选择cp，做一下调整 其他input也可自行调整，最后点击simulation，选择option，选第二个，ok，再一次，选下面一个就ok了 最后效果如下 啊啊啊啊啊终于写完了 好累啊，排版好丑·····慢慢来吧 路漫漫其修远兮，吾将上下而求索]]></content>
      <categories>
        <category>Quartus</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Quartus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号爬虫之旅]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%85%AC%E4%BC%97%E5%8F%B7%E7%88%AC%E8%99%AB%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[微信公众号爬虫之旅上次手机没电关机，再次开机发现，微信竟然背着我更新了，看到新版本微信公众号，我懵逼了，这···这也太不友好了吧几天过去错过好多公众号的优质好文，我记得python号称除了不能生孩子之外啥都能干，但是没学过爬虫怎么办？没关系，作为程序员不能服输，干就完了！于是凭借着我看过的几篇爬虫文章开启了微信公众号爬虫之旅 平台：搜狗微信工具：sublime分析首先，浏览一遍搜狗微信搜索文章的过程 输入要搜索的公众号名字，点击搜公众号，跳转到url https://weixin.sogou.com/weixin?type=2&amp;s_from=input&amp;query=路人甲TM&amp;ie=utf8&amp;_sug_=n&amp;_sug_type_= 分析一下这个url的参数，type值为1表示是搜索公众号，值为2表示搜索文章，s_from 固定input，query的值即我们要搜索的公众号，后面一串也是不用变的。 点击对应公众号的连接 新窗口展示出了该公众号的最近十条群发 这个过程结束大体思路已经有了，request直接请求上面的url，将其中的query换成我们想爬的公众号名字]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP学习笔记]]></title>
    <url>%2F2019%2F05%2F29%2FPHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[php是弱类型语言，不需生命变量类型 变量名只能包含字母数字下划线，并且以字母和下划线开头，变量名区分大小写，$this 是一个特殊的变量，不能被赋值。变量名可以用中文。 php定义的全局变量在函数内使用时需要加global，在c语言中全局变量可以直接使用而不需要global。 print和echo echo可以输出一个或多个字符串，无返回值，速度比print慢 print只允许输出一个字符串，有返回值1 php从html中分离： 凡是在一对开始和结束标记之外的内容都会被 PHP 解析器忽略，这使得 PHP 文件可以具备混合内容。 可以使 PHP 嵌入到 HTML 文档中去，如下例所示。php可以放在文档的任意位置。 php文件里面可以放html、css、js等前端语言， 使用条件的高级分离术 12345&lt;?php if ($expression == true): ?&gt; This will show if the expression is true.&lt;?php else: ?&gt; Otherwise this will show.&lt;?php endif; ?&gt; 要输出大段文本时，跳出 PHP 解析模式通常比将文本通过 echo或 print输出更有效率。 PHP是最好的语言。 2019软件工程师现状报告显示：开发者最爱Python，最讨厌PHP PHP的九种数据类型 ​ 四种标量类型 boolean（布尔） 以下值转换成布尔型时被认为是false 布尔值false本身 整型、浮点型、字符串零 空字符串 空数组 NULL 负数？字符串“false”？ integer（整型） float（浮点型） 永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。0.1+0.2 ==≠== 0.3 string（字符型） 单引号与双引号区别：双引号会解析特殊字符以及变量，而单引号不会。 拼接符（并置运算符） 将变量$message中的数据更新到id为$id的位置，下列语句能够执行正确的是： $sql = “update message set message = $message where id = $id;”; × $sql = “update message set message = ‘$message’ where id = $id;”; √ $sql = ‘update message set message = ‘.$message.’where id = ‘.$id.’;’; 三种复合类型 array（数组） object（对象） callable（可调用） 两种特殊类型 resource（资源） NULL（无类型） PHP运算符 注释 单行注释仅仅注释到行末或者当前的 PHP 代码块，视乎哪个首先出现。这意味着在 // … ?&gt; 或者 # … ?&gt; 之后的 HTML 代码将被显示出来：?&gt; 跳出了 PHP 模式并返回了 HTML 模式 PHP是现在使用的最广泛的开源脚本语言，零成本，word press就是用php写的一个框架， 兼容几乎所有服务器，apache，iis都可以运行php页面，支持多种数据库，MySQL，Oracle、SQL server、mongobd···容几乎所有服务器 PHP+MySQL常用语句 PHP表单 $_GET和$_POST区别： $_GET传递的数据会显示在url中，可以收藏，能被缓存，传输类型只允许ASCII字符，不安全，数据长度有限制（URL长度最大是2048个字符） $_POST相对安全，数据长度无限制。通过request body传递参数 表单处理 post 和get的区别，$_GET 和 $_POST超全局变量，访问不需要考虑作用域，可以从任何函数文件访问， 表单验证 表单必填 正则表达式 cookie和session前后端验证登录注册模块总结 注册时，注册信息通过前端验证后通过post请求发送到数据库。 服务器再次校验数据是否规范、符合标准。 服务器将用户信息存储到数据库后，告知浏览器注册成功 用户打开登录界面，输入登录信息，向服务器发送post请求 服务器读取本地数据库，比对登录信息是否正确，若错误，告知浏览器登录失败；若正确给浏览器设置cookie 浏览器向服务器发送get请求，访问首页，附上cookie 服务器读取cookie，验证身份后，同意浏览器访问首页 作者：tinaawang 链接：https://www.jianshu.com/p/9a728123fa73 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 test PHP 安全 xss 分页分页的两种实现方法 12345 $offset = 10*$page;select * from message limit 10 offset $offset;select * from message limit(10,$offset); 1mysqli_data_seek($res,$offset); include和require​ require 和 include 几乎完全一样，除了处理失败的方式不同之外。require 在出错时产生 E_COMPILE_ERROR 级别的错误。换句话说将导致脚本中止而 include只产生警告（E_WARNING），脚本会继续运行。 ​ 如果文件被包含两次，PHP 5 发出致命错误因为函数已经被定义。 ​ 推荐使用include_once 而不是检查文件是否已包含并在包含文件中有条件返回。 require_once 语句和 require语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。 类和对象 类的定义以关键字class开头，后面跟着类型，后面跟着或括号，里面包含类的属性和方法的定义。 类名同样只能包含字母数字下划线，并且以字母或下划线开头。 一个类可以有自己的常量、变量（属性）和函数（方法）。 创建类的实例使用new关键字 new className(); includes 一个类可以在声明中用extends继承另一个类的方法和属性，PHP不支持多重继承，一个类只能继承一个基类。 被继承的方法和属性可以通过用同样的名字覆盖，但是如果父类方法时用了final，则该方法不可覆盖。可以通过parent:: 来访问被覆盖的方法和属性。 覆盖方法时，参数必须保持一致，否则PHP将发出E_STRCT级别的错误。但构造函数例外，构造函数可以在覆盖时使用不同的参数。 ::class关键字可以用于类名的解析，使用ClassName::class可以获取一个字符串，包含了ClassName的完全限定名称，这对使用了命名空间的类尤其重要。 属性 类的变量成员叫做属性，或者叫字段、特征。 声明属性由关键字public、private、protected开头，然后跟一个普通的变量声明来组成。 在类的成员方法里面，可以用 -&gt;（对象运算符）：$this-&gt;property（其中 property 是该属性名）这种方式来访问非静态属性。静态属性则是用 ::（双冒号）：self::$property来访问。 类常量 把类中保持不变的值定义为类常量，在定义和使用常量的时候不需要$; 访问控制 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。 范围解析操作符 一对冒号，可以用于访问静态成员，类常量，还可以用于覆盖类中的属性和方法。 重载 PHP提供的重载是指动态的创建类属性和方法。通过魔术方法实现。 遍历对象 foreach语句，默认情况下，所有可见属性都将被用于便利。（foreach便利所有其能够访问的可见属性）。 魔术方法 PHP将所有以__（两个下划线）开头的类方法保留为魔术方法，所以在定义类方法时，除了上述魔术方法，不要以 __为前缀。 final关键字 PHP5新增，如果父类的方法被声明为final，则子类无法覆盖该方法，如果一个类被声明为final，则该类不能被继承。 属性不能被定义为final，只有类和方法才能被定义为final。 对象比较 当使用比较运算符（==）比较两个对象变量时，比较的原则是：如果两个对象的属性和属性值都相等，并且两个对象是同一个类的实例，那么这两个对象相等。 如果使用全等运算符（===）比较，这两个对象一定要指向某一个类的同一实例。 类型约束 抽象类 定义为抽象的类不能被实例化。 任何一个类，如果它里面至少有一个方法被声明为抽象的，则它必须定义为抽象类 继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的。 命名空间 在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题： 用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。 为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。 PHP 命名空间提供了一种将相关的类、函数和常量组合到一起的途径。 虽然任意合法的PHP代码都可以包含在命名空间中，但只有以下类型的代码受命名空间的影响，它们是：类（包括抽象类和traits）、接口、函数和常量。 命名空间通过关键字namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间，除了一个以外：declare关键字。所有非PHP代码包括空白符都不能出现在命名空间之前 GET和POST网页乱码mysqli_query(“set names utf8”); 指定客户端将用于将SQL语句发送到服务器的字符集。告诉服务器以后从客户端传来的信息是utf-8编码的，指定服务器用于将结果返回客户端的字符集。 mysqli_set_charset($con,’utf8’);这应该是首选的用于改变字符编码的方法，不建议使用mysqli_query()执行SQL请求的SET NAMES …（如 SET NAMES utf8） ::和-&gt;区别:: 访问静态方法或类常量 -&gt;访问非静态]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
