<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机组成原理]]></title>
    <url>%2F2019%2F06%2F24%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Principle-of-Computer-Composition计算机组成原理思维导图 计算机组成第一章 计算机系统概论冯诺依曼型计算机特点 1.计算机由运算器，控制器，存储器，输入和输出设备5部分组成 2.采用存储程序的方式，程序和数据放在同一个存储器中，并以二进制表示。 3.指令由操作码和地址码组成 4.指令在存储器中按执行顺序存放，由指令计数器(即程序计数器PC)指明要执行的指令所在的储存单元地址，一般按顺序递增，但可按运算结果或外界条件而改变 5.机器以运算器为中心，输入输出设备与存储器间的数据传送都通过运算器区别以运算器为中心的计算机还是存储器的方法 看输入设备能否直接与存储器相连，是的话就是以存储器为中心计算机系统 硬件 结构 主机 cpu ALU运算器 CU控制器 存储器 主存 辅存 I/O 输入设备 输出设备 主要技术指标 机器字长 CPU一次能处理的数据位数 存储容量 存储容量＝存储单元个数×存储字长 运算速度 单位时间执行指令的平均条数，MIPS 软件 系统软件 用来管理整个计算机系统 语言处理程序 操作系统 服务性程序 数据库管理系统 网络软件 应用软件 按任务需要编制成的各种程序第三章 运算方法和运算部件数据的表示方法和转换 机器数正0负1 符号数值化的带符号二进制数，称为机器数。 真值:符号位加绝对值 余三码:在8421码的基础上，把每个编码都加上0011 当两个余三码想加不产生进位时，应从结果中减去0011;产生进位时，应将进位信号送入高位，本位加0011 格雷码:任何两个相邻编码只有1个二进制位不同，而其余3个二进制位相同 8421码 权值从高到低为8、4、2、1 算术运算时，需对运算结果进行修正。 方法：如果小于、等于(1001)2，不需要修正；否则加6修正带符号的二进制数据在计算机中的表示方法及加减法运算 原码 定义 最高位为符号位0/1+数值的绝对值形式 特点 （1）值+0，-0的原码分别为00000、10000，形式不唯一； （2）正数的原码码值随着真值增长而增长 负数的原码码值随着真值增长而减少 （3）n+1位原码表示定点整数范围－(2n－1)——2n－1 n+1位原码表示定点小数范围 －(1－2－n)——1－2－n 运算 绝对值相加减，由数值大小决定运算结果符号 补码 定义，特点和运算 运算:结果不超过机器所能表示范围时，[X+Y]补=[X]补+[Y]补减法运算:[X–Y]补=[X+(–Y)]补=[X]补+[–Y]补 结论 负数的补数＝模＋负数 互为补数的绝对值相加＝模 在补数中，减法运算即加法运算 定义 定义法，即[X]补=2·符号位+X （MOD 2） X为正数，则符号0+X的绝对值；X为负数，则X的绝对值取反+1。 特点 数值零的补码表示唯一 正数补码码值随着真值增大而增大，负数补码码值随着真值增大而增大 n+1位补码所表示定点整数范围－ 2n——2n－1，n+1位补码所表示定点小数范围－1——1－2－n 加法运算逻辑事例 过程 加减法运算的溢出处理 溢出定义 当运算结果超出机器数所能表示的范围 加减中，可能产生溢出的情况 可能出现溢出 同号数相加 异号数相减 不可能出现溢出 异号数相加 同号数相减 判断溢出的方法 法一：当符号相同两数相加，结果符号和加数（或被加数）不相同，则溢出 fa,fb表示两操作数（A,B）的符号位,fs为结果的符号位 法二：任意符号相加，如果C=Cf，则结果正确，否则溢出； C为数值最高位的进位，Cf为符号位的进位 法三：采用双符号相加，如果fs1=fs2，则结果正确，否则溢出； 运算结果的符号位为fs2； 多符号位的补码，叫做变形补码； 如果采用双符号位，当数为小数时，模m=4;当数为整数时，模m=2的n+2次方 反码 定义 a.定义法，即[X]反=(2-2-n)·符号位+X (MOD 2-2-n) b.X是正数，[X]反=[X]原；X是负数，符号+数值取反。 特点 数值零的反码表示不唯一 正数反码码值随着真值增大而增大，负数反码码值随着真值增大而增大 n+1位反码所表示定点整数范围－ (2n－1)——2n－1，n+1位反码所表示定点小数范围－(1－2－n)——1－2－n 加减运算特点 在机器数范围内，反码运算满足[X+Y]反=[X]反+[Y]反，[X－Y]反=[X]反+[－Y]反 反码运算在最高位有进位时，要在最低位+1，此时要多进行一次加法运算，增加了复杂性，又影响了速度，因此很少采用 由于反码运算是以2-2的-次方为模，所以，当最高位有进位而丢掉进位(即2)时，要在最低位+/-1 移码 由来及窍门 为了从码值直接判断对应真值的大小，所以引进移码 [X]补的符号位取反，即得[X]移 特点 最高位是符号位，1表示正，0表示负 数据0有唯一的编码 移码码值随着真值增大而增大 n+1位移码所表示定点整数范围－ 2n——2n－1， n+1位移码所表示定点小数范围－1——1－2－n 计算机中，移码常用于表示阶码，故只执行加、减运算 计算机中，移码运算公式需要对结果进行修正 浮点数的阶码运算 移码定义:[X]移=2的n次方+X 补码定义:[X]补=2的n+1次方+Y 阶码求和公式 [X]移+[Y]补=[X+Y]移 mod2的n+1次方 [X]移+[-Y]补=[X-Y]移 判溢方法 双符号位参加运算，最高符号位恒置0 当结果最高符号位=1则溢出 低位符号=0，则上溢；低位符号=1，则下溢； 当结果最高符号位=0则未溢出 低位符号=0，负数；低位符号=1，正数 说明:如果阶码运算的结果溢出，上述条件不成立。此时，使用双符号位的阶码加法器，并规定移码的第二个符号位，即最高符号位恒用0参加加减运算，则溢出条件是结果的最高符号位为1。此时低位符号为0时，表明结果上溢;为1时，表明结果下溢。当最高符号位为0时，表明没有溢出，低位符号位为1，表明结果为正;为0时表明结果为负。 补，反，原，移码的相互转换 反码-》原码 方法：符号位不变，正数不变，负数数值部分取反。 补码-》原码 方法1：正数不变，负数数值部分求反加1。 方法2：串行转换 从最后开始数，遇到第一个“1”，除第一个“1”不变，前面数字分别取反 移码-》原码 方法：移码转换为补码，再转换为原码 数据从补码和反码表示形式转换成原码 自低位开始转换，从低位向高位，在遇到第一个1之前，保存各位的0不变，第一个1也不变，以后得各位按位取反，最后保持符号位不变，经历一遍后，即可得到补码 定点数和浮点数 定点数 小数点固定在某个位置上的数据 32位定点小数、定点整数补码的范围 32位定点小数-1～1-2-31 32位定点整数-231～231-1 浮点数 根据IEEE754国际标准，常用的浮点数有两种格式 Nmax=Mmax2的EmaxNmin=Mmin2的Emax 单精度(32位)=8位阶码+24位尾数 单精度浮点数(32位)，阶码8位(含一位符号位)，尾数24(含一位符号位)，取值范围:-2的127次方～(1-2的-23次方)*2的127次方 双精度(64位)=11位阶码+53位尾数 双精度浮点数(64位)，阶码11位(含一位符号位)，尾数53位(含一位符号位)，取值范围:-2的1023次方～(1-2的-52次方)*2的1023次方 为了保证数据精度，尾数通常用规格化形式表示:当R=2，且尾数值不为0时，其绝对值应大于或等于(0.5)10 左规 右规 小数点位置可以浮动的数据。 表示形式：N = M · RE 计算机中存储形式 Ms+Es+E(n位)+M(m位) 阶码E，一般为整数，用补码或者移码表示； 尾数M，一般为规格化的定点小数，用补码表示；二进制乘法运算 定点原码一位乘法 两个原码数相乘，其乘积的符号为相乘两数符号的异或值，数值则为两数绝对值之积 [X·Y]原=[X]原·[Y]原=(X0⊕Y0)|(X1X2..Xn) · (Y1Y2..Yn) 几点结论 从低到高根据乘数每位0、1决定相加被乘数还是0； 相加数每次左移，最后一起求积； 符号由异或决定 表达式 电路框架 修正 1.在机器内多个数据一般不能同时相加，一次加法操作只能求出两数之和，因此每每求得一个相加数，就与上次部分积相加 2.人工计算时，相加数逐次向左偏移一位，由于最后的乘积位数是乘数(或被乘数)的两倍，如按此算法在机器中运算，加法器也需增到两倍。观察计算过程很容易发现，在求本次部分积时，前一次部分积的最低位不再参与运算，因此可将其右移一位，相加数可直送而不必偏移，于是用N位加法器就可实现两个N位数相乘 部分积右移时，乘数寄存器同时右移一位，这样可以用乘数寄存器的最低位来控制相加数(取被乘数或零)，同时乘数寄存器的最高位可接受部分积右移出来的一位，因此，完成乘法运算后，A寄存器中保存乘积的高位部分，乘数寄存器中保存乘积低位部分 例题 控制流程图 定点补码一位乘法 表达式 [X·Y]补=[X]补·(－Y0+Y1·2-1+….Yn·2-n) 注意：此处为双符号位，当最后乘积高位为负数时，需要补充加上[-|x|]补的操作二进制除法 加减交替法 当余数为正时，商上1，求下一位商的办法是，余数左移一位，再减去除数;当余数为负时，商上0，求下一位商的办法是，余数左移一位，再加上除数。此方法不用恢复余数，所以又叫不恢复余数法。但若最后一次上商为0而又需得到正确余数，则在这最后扔需恢复余数浮点数的运算方法 浮点数的加减法运算 1.对阶操作 求出△E，再对小的进行移位 2.尾数的加减运算 3.规格化操作 规则简化是符号位和数值最高位不同，即00.1xxxx或11.0xxxx 4.舍入 超出表示范围的高位为1舍入 5.检查阶码是否溢出 浮点数的乘除法运算 1.浮点数阶码运算(移码) 牢记公式 [X+Y]移=[X]移+[Y]补 [X–Y]移=[X]移+[–Y]补 2.按照一位乘或加减交替除运算 先确定符号，在列式子计算运算部件 ABC寄存器作业 定点运算部件 浮点运算部件 由阶码运算部件和尾数运算部件组成数据校验码 码距 任意两个合法码之间不相同的二进制位数的最小值 要具有差错能力，则码距&gt;1 合理增大码距，就能提高发现错误的能力 鉴定方法 有无差错能力 是否能合理增大码距 奇偶校验码 能发现数据代码中一位或奇数个位出错情况的编码 实现原理是使码距由1增加到2 步骤1：在字节高位补充一位，即校验位 步骤2：依据图3.10电路形成原始数据D8..D1的校验位值 步骤3：将9位数据写入主存 步骤4：读出该数据时，读取数据D8..D1通过图3.10判定合法性 电路图 结论 （1）奇偶校验码只能发现一位或奇位错，且不能确定出错位置 （2）奇偶校验码的码距=2 海明校验码 海明码位号和校验位位号的关系 Pi的位置在2的i-1次方，但是除了最高位 笔记 3,5,7||3,6,7||5,6,7 电路图 海明码码距为4 纠一位错，查一位错 2∧r≥k+r+1 纠一位错，查两位错 2∧(r–1)≥k+r 循环冗余校验码(CRC) CRC码可以发现并纠正信息存储或传送过程中连续出现的多位错误 CRC码一般是指k位信息码之后拼接r位校验码 模2运算 模2加减 模2乘除 异或逻辑 CRC的译码与纠错 更换不同的待测码字可以证明:余数与出错位的对应关系是不变，只与码制和生成多项式有关 图第四章 主存储器主存储器处于全机中心低位辅助存储器或称为外存储器，通常用来存放主存的副本和当前不在运行的程序和数据主存储器的类型 随机存储器RAM 非易失性存储器主存储器的主要技术指标 主存容量 64×8等等 计算机可寻址的最小信息单元是一个存储字 主存储器存储单元的总数 存取速度 由存储器存取时间和存储周期表示 存储器存取时间 启动一次存储器操作(读/写)到完成该操作所经历的时间 存储周期 连续启动两次独立的存储器操作所间隔的最小时间主存储器的基本操作 CPU通过使用AR(地址寄存器)和DR(数据寄存器)和主存进行数据传送 若AR为K位字长，DR为n位字长，则允许主存包含2∧k个可寻址单元 CPU与主存采取异步工作方式，以ready信号表示一次访存操作的结束读/写存储器 随机存储器(RAM)按存储元件在运行中能否长时间保存信息分为静态存储器和动态存储器 静态存储器，利用触发器保存信息，只要不断电，信息就不会丢失 电路简图 MOS静态存储结构图 动态存储器，利用MOS电容存储电荷来保存信息，需要不断给电容充电才能使信息来保存信息 电路简图 16K×1位动态存储器框图 再生 集中式 分散式 时间小于或等于2ms 行读出再生非易失性半导体存储器 只读存储器ROM 只读不能写 可编程序的只读存储器PROM 一次性写入 可擦可编程序的只读存储器EPROM 可多次写入、读出 可电擦可编程序只读存储器E2PROM 可多次读出但写入次数有限 快擦除读写存储器Flash Memory 重复写入、读出存储器的组成与控制 存储器容量扩展 位扩展:用多个存储器芯片对字长进行扩充 字扩展:增加存储器中字的数量，提高存储器的寻址范围 字位扩展，假设一个存储器的容量为M×N位，若使用L×K位存储器芯片，那么，这个存储器共需要(M/L)×(N/K)个存储器芯片多体交叉存储器 提高访存速度的方式 采用高速器件 采用层次结构 调整主存结构 计算机中大容量的主存可由多个存储体组成，每个存储体都具有自己的读写线路，地址寄存器和数据寄存器，称为”存储模块”。这种多模块存储器可以实现重叠与交叉存取 第i个模块M的地址编号应按下式给出:M×j+i 连续地址分布在相邻的不同模块内，而同一模块内的地址都是不连续的第五章:指令系统指令系统的发展 20世纪70年代末人们提出了便于VLSI实现的精简指令系统计算机，简称RISC，同时将指令系统越来越复杂的计算机称为复杂指令系统计算机，简称CISC指令格式 结构(操作码+地址码) 操作码 操作数的地址 操作结果的存储地址 下一条指令的地址 地址码 零地址指令 一地址指令 寻址范围 224 = 16 M 2次访存 二地址指令 寻址范围 212 = 4 K 4 次访存 三地址指令 寻址范围 28 = 256 4 次访存 多地址指令 寻址范围 26 = 64 4 次访存 指令字长 取决因素 操作码的长度 操作数地址的长度 操作数地址的个数 指令字长 固定 指令字长 = 存储字长 指令字长 可变 按字节的倍数变化 对准边界存放 不连续存放数据 按字节编址 a.半字地址最低位恒为0 b.字地址最低两位恒为0 c.双字地址的最低三位恒为0 减少访存次数，浪费存储空间 不 对 准 边 界 存 放 连续存放数据 节约存储器空间，但增加访存次数，对多字节数据存在调整高 低字节位置的问题 寻址方式 确定本条指令的数据地址 下一条要执行的指令地址的方法 指令操作码的扩展技术 指令操作码的长度决定了指令系统中完成不同操作的指令数 若某机器的操作码长度固定为K位，则它最多只能有2^K条不同指令 指令操作码两种格式 固定格式 优点:对于简化硬件设计，减少指令译码时间非常有利 缺点:指令少，浪费地址 可变格式(分散地放在字的不同字段) 优点:指令多，缩短指令平均长度，减少程序总位数，增加指令字所能表示的操作信息 缺点:译码复杂，控制器的设计难度增大 拓展方法的一个重要原则 使用频度(即指令在程序中出现概率)高的指令应分配短的操作码，使用频度低的指令相应地分配较长的操作码 指令系统的兼容性 保持系统向上兼容精简指令系统计算机（RISC）——用于小型机复杂指令系统计算机（CISC）——用于大型机第六章：中央处理器计算机工作过程 加电——》产生reset信号——》执行程序——》停机——》停电 产生reset信号的任务 任务一：使计算机处于初始状态 任务二：从PC中取出指令地址 控制器作用是协调并控制计算机各部件执行程序的指令序列控制器的组成 控制器的功能 取指令 发出指令地址，取出指令的内容 分析指令 （1）对操作码译码产生操作相应部件的控制信号 （2）根据寻址方式形成操作数地址 执行指令 （1）根据分析指令后产生控制信号、操作数地址信号序列，通过CPU及输入输出设备的执行实现每条指令的功能 （2）结果回送存储器 （3）形成下条指令的地址 控制程序和数据的输入和结果输出 对异常情况和某些请求的处理 异常情况的处理：例如算术运算的溢出、数据传送奇偶错 某些请求的处理 “中断请求”信号 DMA请求信号 控制器的组成 程序计数器（PC） 即地址寄存器，用来存放当前正在执行的指令地址或即将要执行的下一条指令地址 指令寄存器（IR） 用以存放当前正在执行的指令，以便在指令执行过程中控制完成一条指令的全部功能 指令译码器或操作码译码器 对指令寄存器中的操作码进行分析解释，产生相应的控制信号 脉冲源及启停线路 脉冲源参数一定评率的脉冲作为整个机器的时钟脉冲，是机器周期和工作脉冲的基准信号，在机器刚加电时，还应产生一个总清信号（reset） 时序控制信号形成部件 当程序启动后，在CLK时钟作用下，根据当前正在执行的指令的需要，产生相应的时序控制信号，并根据被控制功能部件的反馈信号调整时序控制信号 控制存储器 微指令寄存器 控制字段+下址 周期概念 指令周期 完成一条指令所需的时间，包括取指令、分析指令、执行指令 机器周期 也称为CPU周期，是CPU从内存中读取一个指令的时间，通常等于取指周期 时钟周期 称为节拍脉冲或T周期，是基准脉冲信号 三条假设 程序是存放在主存中的，当执行完一条指令后才从主存中取下一条指令（非流水线） 指令的长度是固定的，并限制了寻址方式的多样化 在程序运行前，程序和数据都已存在主存中 指令执行过程（运算器和控制器配合） 组成控制器的基本电路 具有记忆功能的触发器以及由它组成的寄存器，计数器和存储单元 没有记忆功能的门电路及由它组成的加法器，算术逻辑运算单元（ALU）和各种逻辑电路 举例 加法 取指令——》计算操作数地址——》取操作数——》执行结果并运算送结果 要能看懂时序图 哪些指令在对应的时间有效 条件转移指令 取指令——》计算地址 控制器的功能就是按每一条指令的要求产生所需的控制信号 产生控制信号的方法 微程序控制 硬布线控制微程序控制计算机的基本工作原理 基本概念 微指令 在微程序控制的计算机中，将由同时发出的控制信号所执行的一组微操作 微命令 将指令分为若干条微指令，按次序执行这些微指令。组成微指令的操作即微命令 微程序 计算机的程序由指令序列构成，而计算机每条指令的功能均由微指令序列解释完成，这些微指令序列的集合就叫做微程序 控制存储器 微程序一般是存放在专门的存储器中的，由于该存储器主要存放控制命令（信号）与下一条执行的微指令地址（简称下址） 存储单元内容 （1）微指令的控制信号——控制位 （2）下条微指令的地址——下址字段 存储芯片：ROM 执行一条指令实际上就是执行一段存放在控制存储器中的微程序 实现微程序控制的基本原理 控制信号（23条） 书上P123页为加法的过程 微指令格式：控制字段+下址字段 23个控制位，12个下址位——》容量为4K 取址微指令的操作对所有指令都是相同的，所以是一条公用的微指令，其下址由操作码译码产生 微程序控制器 时序信号及工作脉冲的形成 停机和停电的区别 停机 电压：稳定 存放内容：保持 重启PC内容：断点指令地址 停电 电压：消失 存放内容：RAM的内容消失 重启PC内容：第一条指令地址微程序设计技术 如何缩短微指令字长 直接控制法（容量太小） 编译方法：每一位代表一个控制信号，直接送往相应的控制点 优点：控制简单 缺点：微指令字长过大 字段直接编译法 选出互斥的微指令 每个字段都要留出一个代码，表示本段不发出任何指令（000） 优点：节省微指令的字长 缺点：增加了额外的硬件开销 字段间接编译法 指令之间相互联系的情况 举例：A为0-7，B为0-3，如果是直接编译——3+2=5，如果是间接编译——3+1=4 编码方法：在字段直接编译法中，译码输出端要兼由另一字段中的某些微命令配合解释 优点：减少了微指令长度 缺点：可能削弱微指令的并行控制能力，同时增加硬件开销 常熟源字段E(了解) 如何减少微指令长度 现行微指令/微地址 现行微指令：当前正在执行的指令 现行微地址：存放现行微指令的控制器存储单元 后继微指令/微地址 后继微指令：下一条要执行的微指令 后继微地址：存放后继微指令的控制器存储单元 增量与下址字段结合产生后继微指令的方法 下址字段分成：转移控制字段BCF和转移地址字段BAF BCF：控制微程序的转移情况 BAF：转移后的微指令所在地址 BAF有两种情况 与uPC的位数相等——转移灵活，但增加微指令长度 比uPC短——转移地址收到限制，但可缩短微指令长度 优点 微指令的下址字段很短，仅用于选择输入uPC计数器的某条线路有效 缺点 微程序转移不灵活，使得微程序在控存中的物理空间分配有困难 多路转移方式 一条微指令存在多个转移分支的情况称为多路转移 微中断 1.微中断请求信号是由程序中断请求信号引起的 2.在完成现行指令的微程序后响应该微中断请求 3.由硬件产生对应微中断处理程序在控存中的入口地址 如何提高微程序的执行速度 微指令格式 水平型微指令——直接控制，字段编译（直接、间接） 特点：在一条微指令中定义并并行执行多个微命令 垂直型微指令 特点：不强调实现微指令的并行控制功能 定义：采用微操作码编译法，由操作码规定微指令的功能 微程序控制存储器 一般采用ROM存储器 也可采用RAM，为防止断电后内容消失，则必须开机后将外存中存放的微程序调入控存RAM，然后才能执行程序。 当前为了能不断扩展指令系统，通常采用ROM+RAM 动态微程序设计 定义：能根据用户要求改变微程序 优点：是计算机能更灵活、有效的适应于各种不同的应用目标 控制存储器的操作（P136） 串行方式 并行方式——比串行多了微指令寄存器 微周期=max(取微指令时间,执行微指令时间) 由于取微指令、执行微指令同时进行，故对于某些后继微地址的产生根据处理结果而定的微指令，则延迟一个微周期再取微指令硬布线控制的计算机（RISC）——特点快 形成操作控制信号的逻辑框图（P141） 操作控制信号的产生 取值周期cy1所产生的信号对所有指令都是相同的，即与当前执行的指令无关，逻辑式得到最简单的形式 通常，同一个控制控制信号在若干条指令的某些周期（或再加上一些条件）中都需要，为此需要把它们组合起来 同种类型的指令所需要的控制信号大部分是相同的，仅有少量区别 在确定指令的操作码时（即对具体指令赋予二进制操作码），为了便于逻辑表达式的化简以减少逻辑电路数量，往往给予特别关注 设计组合逻辑电路从而产生需要的控制信号的步骤 1.实际逻辑问题2.真值表3.公式化简4.逻辑电路图 设计目标 使用最少的电路元件达到最高的操作速度流水线工作原理 几点结论 每条指令的执行时间不变 每条指令处理结果的时间缩短 流水线处理速率最高时=流水线处于满载的稳定状态 流水线处理速率最低时=流水线未满载状态 为了满足在重叠时间段不同指令的机器周期能够完成指定的操作，将时间段=操作完成的最长时间 为了保证一个周期内流水线的输入信号不变，相邻时间段之间必须设置锁存器或寄存器 除了指令执行流水线，还有运算操作流水线 相关问题 流水线阻塞（P163-6.15） 数据相关产生 假设第二条指令需要的操作数是第一条指令运算的结果，那么出现了数据相关 指令执行时间不同产生 程序转移的影响 异常情况响应中断第七章：存储系统存储系统的层次结构 cache-&gt;主存-&gt;辅存高速缓冲存储器 cache的工作原理 局部性原理 主存地址和cache地址（P166 图7.2） 块长 块长一般取一个主存周期所能调出的信息长度（一般为16个字） cache的容量和块的大小是影响cache的效率的重要因素 命中率 CPU所要访问的信息是否在cache中的比率，而将所要访问的信息不在cache中的比率称为失败率 一致性策略 标志交换方式（写回法） 通过式写入（写通法） 写操作直接对主存进行，而不写入cache cache的存取时间 平均存取时间=h*tc+(1-h)(tc+tm) 最好替换策略 按照被替换的字块是下一段时间最少使用的，由替换部件实现 cache组织 地址映像 直接映像 cache中许多空的位置被浪费 主存地址：主存字块标记+cache字块地址+字块内地址 全相联映像 成本太高而不能采用 主存地址：主存字块标记+字块内地址 优点 方式灵活，缩小了块发生冲突的概率 缺点 增加了标识位位数 增加了寻找主存块在cache中对应块的时间 组相联映像 直接映像和全相联映像的折衷 主存地址：主存字块标记+组地址+块内地址虚拟存储器 存储管理部件（MMU） 现代计算机一般都有辅助存储器，但具有辅存的存储系统不一定是虚拟存储系统 虚拟存储系统的特点 允许用户程序用比主存大的多的空间来访问主存 每次访存都要进行虚实地址的转换第八章：辅助存储器半导体存储器可随机访问任一单元，而辅助存储器一般为串行访问存储器辅助存储器的种类 磁表面存储器 数字式磁记录 硬盘、软盘和磁带 模拟式磁记录 录音、录像设备 光存储器 光盘串行存储器 顺序存取存储器 直接存取存储器辅助存储器的技术指标 存储密度 定义：单位长度或单位面积磁层表面磁层所存储的二进制信息量 道密度 沿磁盘半径方向单位长度的磁道数称为道密度，单位为道/英寸tpi或道/毫米tpmm 位密度或线密度 单位长度磁道所能记录二进制信息的位数叫位密度或线密度，单位为位/英寸bpi或位/毫米bpmm 每个磁道所存储的信息量是一样的 存储容量 C = n × k × s 寻址时间 平均寻址时间Ta=平均找道时间Ts+平均等待时间Tw 辅存的速度 寻址时间 磁头读写时间 数据传输率 Dr = D × V 误码率 价格硬磁盘存储器的类型 (1) 固定磁头和移动磁头 (2) 可换盘和固定盘磁盘存储器 温彻斯特磁盘简称温盘 磁盘存储器由驱动器（HDD），控制器（HDC）和盘片组成 最外面的同心圆叫0磁道，最里面的同心圆假设称为n磁道 驱动器的定位驱动系统实现快速精准的磁头定位 主轴系统的作用是带动盘片按额定转速稳定旋转 数据控制系统的作用是控制数据的写入和读出，包括寻址，磁头旋转，写电流控制，读出放大，数据分离 磁盘控制器有两个方向的接口 与主机的接口 与驱动器（设备）的接口光盘 采用光存储技术 利用激光写入和读出 第一代光存储技术 采用非磁性介质 不可擦写 第二代光存储技术 采用磁性介质 可擦写 光盘的存储原理 只读型和只写一次型 热作用（物理或化学变化） 可擦写光盘 热磁效应第九/十章：输出输出（I/O）设备/系统设备控制器（I/O）的基本功能 实现主机和外部设备之间的数据传送 实现数据缓冲，以达到主机同外部设备之间的速度匹配 接受主机的命令，提供设备接口的设备，并按照主机的命令控制设备I/O 编址方式 (1) 统一编址：用取数、存数指令 (2) 不统一编址：有专门的 I/O 指令I/O 与主机的连接方式 辐射式连接 每台设备都配有一套 控制线路和一组信号线 不便于增删设备 总线连接 便于增删设备I/O设备 人机交互设备 键盘、鼠标等 计算机信息的驻留设备 硬盘、光盘等 机——机通信设备 MODEN等为什么要设置接口？ 实现设备的选择 实现数据缓冲达到速度匹配 实现数据串 并格式转换 实现电平转换 传送控制命令 反映设备的状态 （“忙”、“就绪”、“中断请求”）中断服务程序的流程 (1) 保护现场 程序断点的保护 寄存器内容的保护 (2) 中断服务 对不同的 I/O 设备具有不同内容的设备服务 (3) 恢复现场 出栈指令 (4) 中断返回 中断返回指令单重中断和多重中断 单重 中断 不允许中断 现行的 中断服务程序 多重 中断 允许级别更高 的中断源 中断 现行的 中断服务程序DMA 方式 主存和 I/O 之间有一条直接数据通道 CPU 和 I/O 并行工作 DMA 的三种工作方式 (1) CPU暂停方式 (2) CPU周期窃取方式 (3)直接访问存储器 DMA 接口功能 (1) 向 CPU 申请 DMA 传送 (2) 处理总线 控制权的转交 (3) 管理 系统总线、控制 数据传送 (4) 确定 数据传送的 首地址和长度，修正 传送过程中的数据地址和长度 (5) DMA 传送结束时，给出操作完成信号 DMA 传送过程 预处理、数据传送、后处理外设接口 设备与主机相连时，必须按照规定的物理互连特性、电气特性等进行连接，这些特性的技术规范称为接口标准]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Quartus II安装破解及基础操作]]></title>
    <url>%2F2019%2F06%2F03%2FQuartus-II%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Quartus II安装破解及基础操作安装了hexo之后第一篇博客本来是python爬虫的，结果在问题复现的时候自己的ip被封了，途中也发现有其他的方法，所以耽误了一段时间，才写了一半，争取尽快写完发出来。 第一次写博客，感觉肚子里没点墨水还真是不行，那就从小的知识开始写吧 为了能够在周四给老师交作业的时候不忘记步骤掉链子，以及方便以后用的时候再看，这次就先是今天Quartus使用的简单记录。 安装破解 安装 安装包以及破解要使用的工具已经放[某云盘](链接: https://pan.baidu.com/s/1Un_7PJ8mWCU9o5GOtCJf9w 提取码: 5v0x)了，自行取用。 安装很简单，打开安装程序，除中间可自行选择安装路径(安装路径后面用的到)外，其余一路next下来就好，就不再多说。 破解在破解器压缩包里，提供了32位和64位电脑用到的破解软件，这里以64位为例。解压然后将其中的可执行文件复制到 安装路径下\quartus\bin64 例如我的在E:\altera\13.0sp1\quartus\bin64 文件位置不对的话会出现这样一个提示 OK现在要关掉电脑的杀毒软件，否则的话会被当成病毒清理掉，打开破解程序，点击应用，保存license.dat文件退出即可 打开安装好的Quartus，选择第二项 Tools-&gt;license setup 在下面network Interface····复制第一个(第一个逗号之前的)出来，用sublime打开刚才的license文件，替换下图中的XXX 保存关闭重启，破解就完成了。破解之后在刚才的license setup中我们看到,可以用的2035年嘻嘻嘻。 破解就结束了。 其实很多带有试用期的软件像PHP storm这种还有一个更加简单的破解方法。那就是在打开软件选在30天适用之前修改系统时间，然后再选择适用，那么试用期就会到你定的时候开始适用一段时间。 例如我们选择试用期之前把系统时间改成2099.1.1，那么三十天试用期的截至时间就是2099.2.1 嘿嘿嘿···· 使用 原件建模及连接这次作业做的是累加器（计数器？）+ALU，累加器从0-15，输出结果连到ALU的S端。 第一个问题就是怎么把两个模块连起来呢？ 不绕圈子了·····字实在太多了，现在已经半夜12点了····· 在项目中新建一个Verilog HDL file 写出原件对应的代码，如一个简单的累加器代码如下 代码写完点击Processing下面的Analysis Current File，成功之后在左边的文档树中找到这个文件右键选择倒数第二个 这样一个原件就出来了，找到ALU的bdf文件打开，在空白处双击，在project下选择元件的模块名称，ok放到对应位置即可。这样两个元件就联系起来了。 仿真电路图连接好之后就需要仿真，首先得编译，选择processing下面的start compilation或者上面的符号开始编译。 等待编译成功后新建一个vwf file,在左侧空白处双击， 然后选择cp，做一下调整 其他input也可自行调整，最后点击simulation，选择option，选第二个，ok，再一次，选下面一个就ok了 最后效果如下 啊啊啊啊啊终于写完了 好累啊，排版好丑·····慢慢来吧 路漫漫其修远兮，吾将上下而求索]]></content>
      <categories>
        <category>Quartus</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Quartus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号爬虫之旅]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%85%AC%E4%BC%97%E5%8F%B7%E7%88%AC%E8%99%AB%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[微信公众号爬虫之旅上次手机没电关机，再次开机发现，微信竟然背着我更新了，看到新版本微信公众号，我懵逼了，这···这也太不友好了吧几天过去错过好多公众号的优质好文，我记得python号称除了不能生孩子之外啥都能干，但是没学过爬虫怎么办？没关系，作为程序员不能服输，干就完了！于是凭借着我看过的几篇爬虫文章开启了微信公众号爬虫之旅 平台：搜狗微信工具：sublime分析首先，浏览一遍搜狗微信搜索文章的过程 输入要搜索的公众号名字，点击搜公众号，跳转到url https://weixin.sogou.com/weixin?type=2&amp;s_from=input&amp;query=路人甲TM&amp;ie=utf8&amp;_sug_=n&amp;_sug_type_= 分析一下这个url的参数，type值为1表示是搜索公众号，值为2表示搜索文章，s_from 固定input，query的值即我们要搜索的公众号，后面一串也是不用变的。 点击对应公众号的连接 新窗口展示出了该公众号的最近十条群发 这个过程结束大体思路已经有了，request直接请求上面的url，将其中的query换成我们想爬的公众号名字]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP学习笔记]]></title>
    <url>%2F2019%2F05%2F29%2FPHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[php是弱类型语言，不需生命变量类型 变量名只能包含字母数字下划线，并且以字母和下划线开头，变量名区分大小写，$this 是一个特殊的变量，不能被赋值。变量名可以用中文。 php定义的全局变量在函数内使用时需要加global，在c语言中全局变量可以直接使用而不需要global。 print和echo echo可以输出一个或多个字符串，无返回值，速度比print慢 print只允许输出一个字符串，有返回值1 php从html中分离： 凡是在一对开始和结束标记之外的内容都会被 PHP 解析器忽略，这使得 PHP 文件可以具备混合内容。 可以使 PHP 嵌入到 HTML 文档中去，如下例所示。php可以放在文档的任意位置。 php文件里面可以放html、css、js等前端语言， 使用条件的高级分离术 12345&lt;?php if ($expression == true): ?&gt; This will show if the expression is true.&lt;?php else: ?&gt; Otherwise this will show.&lt;?php endif; ?&gt; 要输出大段文本时，跳出 PHP 解析模式通常比将文本通过 echo或 print输出更有效率。 PHP是最好的语言。 2019软件工程师现状报告显示：开发者最爱Python，最讨厌PHP PHP的九种数据类型 ​ 四种标量类型 boolean（布尔） 以下值转换成布尔型时被认为是false 布尔值false本身 整型、浮点型、字符串零 空字符串 空数组 NULL 负数？字符串“false”？ integer（整型） float（浮点型） 永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。0.1+0.2 ==≠== 0.3 string（字符型） 单引号与双引号区别：双引号会解析特殊字符以及变量，而单引号不会。 拼接符（并置运算符） 将变量$message中的数据更新到id为$id的位置，下列语句能够执行正确的是： $sql = “update message set message = $message where id = $id;”; × $sql = “update message set message = ‘$message’ where id = $id;”; √ $sql = ‘update message set message = ‘.$message.’where id = ‘.$id.’;’; 三种复合类型 array（数组） object（对象） callable（可调用） 两种特殊类型 resource（资源） NULL（无类型） PHP运算符 注释 单行注释仅仅注释到行末或者当前的 PHP 代码块，视乎哪个首先出现。这意味着在 // … ?&gt; 或者 # … ?&gt; 之后的 HTML 代码将被显示出来：?&gt; 跳出了 PHP 模式并返回了 HTML 模式 PHP是现在使用的最广泛的开源脚本语言，零成本，word press就是用php写的一个框架， 兼容几乎所有服务器，apache，iis都可以运行php页面，支持多种数据库，MySQL，Oracle、SQL server、mongobd···容几乎所有服务器 PHP+MySQL常用语句 PHP表单 $_GET和$_POST区别： $_GET传递的数据会显示在url中，可以收藏，能被缓存，传输类型只允许ASCII字符，不安全，数据长度有限制（URL长度最大是2048个字符） $_POST相对安全，数据长度无限制。通过request body传递参数 表单处理 post 和get的区别，$_GET 和 $_POST超全局变量，访问不需要考虑作用域，可以从任何函数文件访问， 表单验证 表单必填 正则表达式 cookie和session前后端验证登录注册模块总结 注册时，注册信息通过前端验证后通过post请求发送到数据库。 服务器再次校验数据是否规范、符合标准。 服务器将用户信息存储到数据库后，告知浏览器注册成功 用户打开登录界面，输入登录信息，向服务器发送post请求 服务器读取本地数据库，比对登录信息是否正确，若错误，告知浏览器登录失败；若正确给浏览器设置cookie 浏览器向服务器发送get请求，访问首页，附上cookie 服务器读取cookie，验证身份后，同意浏览器访问首页 作者：tinaawang 链接：https://www.jianshu.com/p/9a728123fa73 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 test PHP 安全 xss 分页分页的两种实现方法 12345 $offset = 10*$page;select * from message limit 10 offset $offset;select * from message limit(10,$offset); 1mysqli_data_seek($res,$offset); include和require​ require 和 include 几乎完全一样，除了处理失败的方式不同之外。require 在出错时产生 E_COMPILE_ERROR 级别的错误。换句话说将导致脚本中止而 include只产生警告（E_WARNING），脚本会继续运行。 ​ 如果文件被包含两次，PHP 5 发出致命错误因为函数已经被定义。 ​ 推荐使用include_once 而不是检查文件是否已包含并在包含文件中有条件返回。 require_once 语句和 require语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。 类和对象 类的定义以关键字class开头，后面跟着类型，后面跟着或括号，里面包含类的属性和方法的定义。 类名同样只能包含字母数字下划线，并且以字母或下划线开头。 一个类可以有自己的常量、变量（属性）和函数（方法）。 创建类的实例使用new关键字 new className(); includes 一个类可以在声明中用extends继承另一个类的方法和属性，PHP不支持多重继承，一个类只能继承一个基类。 被继承的方法和属性可以通过用同样的名字覆盖，但是如果父类方法时用了final，则该方法不可覆盖。可以通过parent:: 来访问被覆盖的方法和属性。 覆盖方法时，参数必须保持一致，否则PHP将发出E_STRCT级别的错误。但构造函数例外，构造函数可以在覆盖时使用不同的参数。 ::class关键字可以用于类名的解析，使用ClassName::class可以获取一个字符串，包含了ClassName的完全限定名称，这对使用了命名空间的类尤其重要。 属性 类的变量成员叫做属性，或者叫字段、特征。 声明属性由关键字public、private、protected开头，然后跟一个普通的变量声明来组成。 在类的成员方法里面，可以用 -&gt;（对象运算符）：$this-&gt;property（其中 property 是该属性名）这种方式来访问非静态属性。静态属性则是用 ::（双冒号）：self::$property来访问。 类常量 把类中保持不变的值定义为类常量，在定义和使用常量的时候不需要$; 访问控制 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。 范围解析操作符 一对冒号，可以用于访问静态成员，类常量，还可以用于覆盖类中的属性和方法。 重载 PHP提供的重载是指动态的创建类属性和方法。通过魔术方法实现。 遍历对象 foreach语句，默认情况下，所有可见属性都将被用于便利。（foreach便利所有其能够访问的可见属性）。 魔术方法 PHP将所有以__（两个下划线）开头的类方法保留为魔术方法，所以在定义类方法时，除了上述魔术方法，不要以 __为前缀。 final关键字 PHP5新增，如果父类的方法被声明为final，则子类无法覆盖该方法，如果一个类被声明为final，则该类不能被继承。 属性不能被定义为final，只有类和方法才能被定义为final。 对象比较 当使用比较运算符（==）比较两个对象变量时，比较的原则是：如果两个对象的属性和属性值都相等，并且两个对象是同一个类的实例，那么这两个对象相等。 如果使用全等运算符（===）比较，这两个对象一定要指向某一个类的同一实例。 类型约束 抽象类 定义为抽象的类不能被实例化。 任何一个类，如果它里面至少有一个方法被声明为抽象的，则它必须定义为抽象类 继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的。 命名空间 在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题： 用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。 为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。 PHP 命名空间提供了一种将相关的类、函数和常量组合到一起的途径。 虽然任意合法的PHP代码都可以包含在命名空间中，但只有以下类型的代码受命名空间的影响，它们是：类（包括抽象类和traits）、接口、函数和常量。 命名空间通过关键字namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间，除了一个以外：declare关键字。所有非PHP代码包括空白符都不能出现在命名空间之前 GET和POST网页乱码mysqli_query(“set names utf8”); 指定客户端将用于将SQL语句发送到服务器的字符集。告诉服务器以后从客户端传来的信息是utf-8编码的，指定服务器用于将结果返回客户端的字符集。 mysqli_set_charset($con,’utf8’);这应该是首选的用于改变字符编码的方法，不建议使用mysqli_query()执行SQL请求的SET NAMES …（如 SET NAMES utf8） ::和-&gt;区别:: 访问静态方法或类常量 -&gt;访问非静态]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
